<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lucas-y.github.io/</id>
    <title>前端小白</title>
    <updated>2021-05-07T01:37:16.296Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lucas-y.github.io/"/>
    <link rel="self" href="https://lucas-y.github.io/atom.xml"/>
    <subtitle>知行合一</subtitle>
    <logo>https://lucas-y.github.io/images/avatar.png</logo>
    <icon>https://lucas-y.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 前端小白</rights>
    <entry>
        <title type="html"><![CDATA[input change事件]]></title>
        <id>https://lucas-y.github.io/post/input-change-shi-jian/</id>
        <link href="https://lucas-y.github.io/post/input-change-shi-jian/">
        </link>
        <updated>2021-05-07T01:31:18.000Z</updated>
        <content type="html"><![CDATA[<p>区别:</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[require引入的图片和直接引入的图片到底有什么区别？]]></title>
        <id>https://lucas-y.github.io/post/require-yin-ru-de-tu-pian-he-zhi-jie-yin-ru-de-tu-pian-dao-di-you-shi-me-qu-bie/</id>
        <link href="https://lucas-y.github.io/post/require-yin-ru-de-tu-pian-he-zhi-jie-yin-ru-de-tu-pian-dao-di-you-shi-me-qu-bie/">
        </link>
        <updated>2021-02-03T12:58:26.000Z</updated>
        <content type="html"><![CDATA[<p>require 是 node 中的一个方法，他的作用是 “用于引入模块、 JSON、或本地文件”。 也就是说如果我们使用 require 来引入一个图片文件的话，那么 require 返回的就是用于引入的图片（npm 运行之后图片的编译路径）。 而如果使用字符串的话，那么则是一个 string 类型的固定字符串路径。</p>
<p>我们知道，src 中引入的图片应该为图片的本身路径（相对路径或者绝对路径），而 vue 项目通过 webpack 的 devServer 运行之后，默认的 vue-cli 配置下，图片会被打包成 name.hash 的图片名，在这种情况下，如果我们使用固定的 字符串路径则无法找到该图片，所以需要使用 require 方法来返回 图片的编译路径。</p>
<p>简单的说，使用require定义之后，你就可以动态使用了，不用require你就只能写死的。不用的话， :src=&quot;’…/img/image.jpg’&quot; 会被解析为字符串</p>
<p>require 方法介绍： http://nodejs.cn/api/modules.html#modules_require_id</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端模块化]]></title>
        <id>https://lucas-y.github.io/post/qian-duan-mo-kuai-hua/</id>
        <link href="https://lucas-y.github.io/post/qian-duan-mo-kuai-hua/">
        </link>
        <updated>2021-01-25T09:30:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="js模块化">JS模块化</h2>
<ul>
<li>
<p>模块化的理解</p>
</li>
<li>
<p>什么是模块?</p>
<ul>
<li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li>
<li>块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</li>
</ul>
</li>
<li>
<p>一个模块的组成</p>
<ul>
<li>数据---&gt;内部的属性</li>
<li>操作数据的行为---&gt;内部的函数</li>
</ul>
</li>
<li>
<p>模块化</p>
<ul>
<li>编码时是按照模块一个一个编码的, 整个项目就是一个模块化的项目</li>
</ul>
</li>
<li>
<p>模块化的进化过程</p>
<ul>
<li>
<p>全局function模式 :</p>
<ul>
<li>编码: 全局变量/函数</li>
<li>问题: 污染全局命名空间, 容易引起命名冲突/数据不安全</li>
</ul>
</li>
<li>
<p>namespace模式 :</p>
<ul>
<li>编码: 将数据/行为封装到对象中</li>
<li>解决: 命名冲突(减少了全局变量)</li>
<li>问题: 数据不安全(外部可以直接修改模块内部的数据)</li>
</ul>
</li>
<li>
<p>IIFE模式/增强</p>
<ul>
<li>IIFE : 立即调用函数表达式---&gt;匿名函数自调用</li>
<li>编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口</li>
<li>引入依赖: 通过函数形参来引入依赖模块<pre><code>(function(window, module2){
  var data = 'atguigu.com'
  function foo() {
     module2.xxx()
     console.log('foo()'+data)
  }
  function bar() {
     console.log('bar()'+data)
  }
  
  window.module = {foo}
})(window, module2)
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>模块化规范</p>
<ul>
<li>CommonJS
<ul>
<li>Node.js : 服务器端</li>
<li>Browserify : 浏览器端    也称为js的打包工具</li>
<li>基本语法:
<ul>
<li>定义暴露模块 : exports<pre><code>exports.xxx = value
module.exports = value
</code></pre>
</li>
</ul>
引入模块 : require<pre><code>var module = require('模块名/模块相对路径')
</code></pre>
</li>
<li>引入模块发生在什么时候?
<ul>
<li>Node : 运行时, 动态同步引入</li>
<li>Browserify : 在运行前对模块进行编译/转译/打包的处理(已经将依赖的模块包含进来了),<br>
运行的是打包生成的js, 运行时不存在需要再从远程引入依赖模块</li>
</ul>
</li>
</ul>
</li>
<li>AMD : 浏览器端 <strong>依赖前置</strong>
<ul>
<li>require.js</li>
<li>基本语法
<ul>
<li>定义暴露模块: define([依赖模块名], function(){return 模块对象})</li>
<li>引入模块: require(['模块1', '模块2', '模块3'], function(m1, m2){//使用模块对象})</li>
<li>配置:<pre><code>require.config({
  //基本路径
  baseUrl : 'js/',
  //标识名称与路径的映射
  paths : {
    '模块1' : 'modules/模块1',
    '模块2' : 'modules/模块2',
    'angular' : 'libs/angular',
    'angular-messages' : 'libs/angular-messages'
  },
  //非AMD的模块
  shim : {
    'angular' : {
        exports : 'angular'
    },
    'angular-messages' : {
        exports : 'angular-messages',
        deps : ['angular']
    }
  }
})
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>CMD : 浏览器端 <strong>依赖就近</strong>
<ul>
<li>sea.js</li>
<li>基本语法
<ul>
<li>定义暴露模块:<pre><code>define(function(require, module, exports){
  通过require引入依赖模块
  通过module/exports来暴露模块
  exports.xxx = value
})
</code></pre>
</li>
<li>使用模块seajs.use(['模块1', '模块2'])</li>
</ul>
</li>
</ul>
</li>
<li>ES6
<ul>
<li>ES6内置了模块化的实现</li>
<li>基本语法
<ul>
<li>
<p>定义暴露模块 : export</p>
<ul>
<li>暴露一个对象:<pre><code>export default 对象
</code></pre>
</li>
<li>暴露多个:<pre><code>export var xxx = value1
export let yyy = value2

var xxx = value1
let yyy = value2
export {xxx, yyy}
</code></pre>
</li>
</ul>
</li>
<li>
<p>引入使用模块 : import</p>
<ul>
<li>default模块:<pre><code>import xxx  from '模块路径/模块名'
</code></pre>
</li>
<li>其它模块<pre><code>import {xxx, yyy} from '模块路径/模块名'
import * as module1 from '模块路径/模块名'
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>问题: 所有浏览器还不能直接识别ES6模块化的语法</li>
<li>解决:
<ul>
<li>使用Babel将ES6---&gt;ES5(使用了CommonJS) ----浏览器还不能直接支行</li>
<li>使用Browserify---&gt;打包处理----浏览器可以运行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue-cli]]></title>
        <id>https://lucas-y.github.io/post/vue-cli/</id>
        <link href="https://lucas-y.github.io/post/vue-cli/">
        </link>
        <updated>2021-01-15T02:42:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="脚手架-vue-cli">脚手架 - vue-cli</h1>
<h2 id="vue-cli-介绍">vue-cli 介绍</h2>
<blockquote>
<h1 id="vue-cli是官方提供的开发vue项目的脚手架工具">vue-cli是官方提供的开发vue项目的脚手架工具。</h1>
</blockquote>
<p><strong>脚手架</strong>是为了保证各施工过程顺利进行而搭设的工作平台。</p>
<figure data-type="image" tabindex="1"><img src="https://lucas-y.github.io//post-images/1610681728612.png" alt="" loading="lazy"></figure>
<p>vue-cli 可以快速提供一整套的 <strong>vue项目开发</strong>的 架子, 并且成为了一套开发vue的标准  (底层就是webpack)</p>
<p>提供了一系列工具</p>
<ul>
<li>例如:  babel  语法降级的   https://www.babeljs.cn/    webpack内部配置babel, 可以将高版本语法降级成低版本语法</li>
<li>例如:  eslint   约束语法风格的 (代码风格)  https://eslint.bootcss.com/</li>
<li>例如:  less 的语法转换, 将less转换成css, 供浏览器识别</li>
<li>例如:  提供了一个开发服务器, 保存自动刷新浏览器</li>
<li>....</li>
</ul>
<p>总结:</p>
<ul>
<li>vue-cli 是一个为开发项目提供便利的一个平台, 可以更方便的开发项目, 提高开发效率</li>
</ul>
<h2 id="vue-cli-安装">vue-cli 安装</h2>
<p>全局安装</p>
<pre><code>yarn global add @vue/cli
或
npm i @vue/cli -g
</code></pre>
<p>如果 npm 安装慢，使用淘宝镜像。</p>
<pre><code>npm i @vue/cli -g --registry=https://registry.npm.taobao.org
</code></pre>
<p>查看版本号</p>
<pre><code>vue --version
</code></pre>
<p>如果能够输出版本号，就说明已经成功安装了脚手架工具了。  (例如: <code>@vue/cli 4.5.9</code> )</p>
<p>报错说明:</p>
<figure data-type="image" tabindex="2"><img src="https://lucas-y.github.io//post-images/1610679000841.png" alt="" loading="lazy"></figure>
<p>问题说明: 安装是安装好了, 但是 vue -V 找不到版本  =&gt;  没有配置环境变量 (自动配)</p>
<p>自动配置没有配置上, 需要手动配置</p>
<p>1 查找 yarn 全局安装的目录</p>
<pre><code>yarn global bin
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://lucas-y.github.io//post-images/1610679017709.png" alt="" loading="lazy"></figure>
<p>目录中, 有两个文件,  vue  vue.cmd</p>
<figure data-type="image" tabindex="4"><img src="https://lucas-y.github.io//post-images/1610679050308.png" alt="" loading="lazy"></figure>
<p>2 配置环境变量</p>
<p>我的电脑  =&gt;  属性  =&gt;  高级系统设置  =&gt;  环境变量  =&gt;  系统环境变量  =&gt;  path   =&gt; 新建一个  =&gt; 粘贴路径即可</p>
<h2 id="vue-cli-创建项目">vue-cli 创建项目</h2>
<p>目标:</p>
<ol>
<li>用 vue-cli工具来创建vue项目。</li>
<li>熟悉 vue项目 结构目录。</li>
</ol>
<h3 id="创建项目">创建项目</h3>
<p>步骤:</p>
<ol>
<li>
<p>打开命令行窗口, 执行命令</p>
<pre><code>vue create 项目名称
</code></pre>
</li>
<li>
<p>选择创建方式, 选择最后的自定义创建</p>
<pre><code class="language-cmd">Vue CLI v4.5.7
? Please pick a preset: (Use arrow keys)
  Default ([Vue 2] babel, eslint)
  Default (Vue 3 Preview) ([Vue 3] babel, eslint)  
&gt; Manually select features
</code></pre>
</li>
<li>
<p>选择需要的模块</p>
<figure data-type="image" tabindex="5"><img src="https://lucas-y.github.io//post-images/1610679073644.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>选择vue版本, 2.x</p>
<figure data-type="image" tabindex="6"><img src="https://lucas-y.github.io//post-images/1610679094148.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>是否采用路由 history 历史模式 (不采用, 这个模式, 需要后台配合)</p>
<figure data-type="image" tabindex="7"><img src="https://lucas-y.github.io//post-images/1610679114543.png" alt="" loading="lazy"></figure>
<pre><code>本质上: 没有跳转页面, 都通过地址栏, 记录跳转的信息
区别: 1. 基于hash值的, 地址栏中, 有 # 号信息
         https://www.baidu.com/#/
         https://www.baidu.com/#/register

      1. 用 history api 模式, 地址栏中, 没有  (后台配合一下)
         https://www.baidu.com/  根路径
         https://www.baidu.com/register  后台需要配置内容, 处理这个地址的访问的

         将所有的页面路径, 都映射到首页, 才能真正访问到你写的单页应用
</code></pre>
</li>
<li>
<p>css预处理器, 选择 less</p>
<figure data-type="image" tabindex="8"><img src="https://lucas-y.github.io//post-images/1610679133889.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>eslint规范, 选择标准化的无分号规范</p>
<figure data-type="image" tabindex="9"><img src="https://lucas-y.github.io//post-images/1610679152434.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>选择是否进行eslint规范校验, 开启保存时校验, (这里直接回车即可)</p>
<figure data-type="image" tabindex="10"><img src="https://lucas-y.github.io//post-images/1610679172505.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>相关的一些配置文件存放在哪, 配置到package.json中即可, 这样目录更简洁</p>
<figure data-type="image" tabindex="11"><img src="https://lucas-y.github.io//post-images/1610679191679.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>是否保存刚才预设的步骤, 输入 n,   (不存了, 我们下次建项目, 还是再一个个选一下加强练习)</p>
<figure data-type="image" tabindex="12"><img src="https://lucas-y.github.io//post-images/1610679219061.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>回车后, 会开始下载, 等待一会, 最后下载成功界面如下</p>
<figure data-type="image" tabindex="13"><img src="https://lucas-y.github.io//post-images/1610679231786.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>启动项目 (<strong>先进入目录</strong>, 再在项目根目录运行 yarn serve)</p>
<pre><code class="language-txt">cd 04-vue-demo

yarn serve
</code></pre>
</li>
</ol>
<p>大工告成!! 去浏览器访问  http://localhost:8080</p>
<figure data-type="image" tabindex="14"><img src="https://lucas-y.github.io//post-images/1610679255476.png" alt="" loading="lazy"></figure>
<h3 id="熟悉目录结构">熟悉目录结构</h3>
<p>利用 vue create 项目名, 会直接生成一套项目的目录</p>
<figure data-type="image" tabindex="15"><img src="https://lucas-y.github.io//post-images/1610679286024.png" alt="" loading="lazy"></figure>
<p>在开发时，我们需要把自己的代码写在<code>src</code>目录下。</p>
<figure data-type="image" tabindex="16"><img src="https://lucas-y.github.io//post-images/1610679306585.png" alt="" loading="lazy"></figure>
<p>目录说明: 为了将来更好的进行开发和维护, 并不会将所有的组件都全部放到 components 文件夹</p>
<p>组件也可以做一个划分:  页面性质的组件 (展示, 路由切换)    通用组件性质的组件 (复用, 封装)</p>
<ol>
<li>
<p>components: 一般存放的是通用的, 在多个页面中复用的组件</p>
<p>例如:  按钮组件 my-button.vue,  表格组件 my-table.vue</p>
</li>
<li>
<p>views: 一般存放的展示相关的页面性质的组件  (配合路由切换)</p>
<p>比如:   login.vue   home.vue    register.vue   user.vue</p>
</li>
</ol>
<p>我们可以将 src 目录清空, 从零开始理解</p>
<figure data-type="image" tabindex="17"><img src="https://lucas-y.github.io//post-images/1610679334840.png" alt="" loading="lazy"></figure>
<p>重新 yarn serve 启动项目</p>
<h3 id="vueconfigjs-文件的作用">vue.config.js 文件的作用</h3>
<p>vue-cli 是基于 webpack 的, 有着默认的 webpack 配置, 如果对默认的配置不满意, 可以进行修改</p>
<p>需要在项目根目录, 新建 <code>vue.config.js</code> 文件,  去覆盖默认的webpack配置</p>
<pre><code class="language-jsx">module.exports = {
  devServer: {
    open: true, // 自动打开浏览器
    port: 8888  // 配置端口号
  }
}
</code></pre>
<h1 id="elint-格式化配置">elint 格式化配置</h1>
<h2 id="基本格式化配置">基本格式化配置</h2>
<p>对于不熟悉eslint规则的我们, 这个报错, 太影响学习效率了, 所以一般会借助 vscode 插件, 辅助我们熟悉eslint的规范</p>
<p>我们可以配置保存时, 自动修复格式bug</p>
<p>步骤:</p>
<ol>
<li>
<p>vscode 安装 eslint 插件 (已安装)</p>
<figure data-type="image" tabindex="18"><img src="https://lucas-y.github.io//post-images/1610679366248.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>将下面的配置代码粘贴到vscode配置文件中  (左下角齿轮 =&gt;  设置 =&gt; 右上角点开 )  (已配置)<br>
<img src="https://lucas-y.github.io//post-images/1610679400472.png" alt="" loading="lazy"></p>
<pre><code class="language-json">&quot;editor.codeActionsOnSave&quot;: {
   &quot;source.fixAll.eslint&quot;: true
}
</code></pre>
</li>
</ol>
<p><strong>配置成功效果图:</strong></p>
<figure data-type="image" tabindex="19"><img src="https://lucas-y.github.io//post-images/1610679418901.png" alt="" loading="lazy"></figure>
<p><strong>注意点:</strong></p>
<p>1 关闭保存时自动格式化</p>
<p>​	formOnSave: false</p>
<p>2 需要将整个项目以根目录的方式, 单独在vscode中打开, 不然eslint插件, 就会不生效 (保存不会自动修复)</p>
<figure data-type="image" tabindex="20"><img src="https://lucas-y.github.io//post-images/1610680908583.png" alt="" loading="lazy"></figure>
<p>错误演示</p>
<figure data-type="image" tabindex="21"><img src="https://lucas-y.github.io//post-images/1610680935143.png" alt="" loading="lazy"></figure>
<h2 id="eslint-不生效补充说明">eslint 不生效补充说明</h2>
<p>一上来弹个框记得选允许</p>
<figure data-type="image" tabindex="22"><img src="https://lucas-y.github.io//post-images/1610680971261.png" alt="" loading="lazy"></figure>
<p>如果没有选, 就会在页面的最上面代码上, 显示个波浪线</p>
<figure data-type="image" tabindex="23"><img src="https://lucas-y.github.io//post-images/1610681006692.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="24"><img src="https://lucas-y.github.io//post-images/1610681023217.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="25"><img src="https://lucas-y.github.io//post-images/1610681043192.png" alt="" loading="lazy"></figure>
<h2 id="eslint-修改配置的说明">eslint 修改配置的说明</h2>
<p>我们是选择, 将配置, 配置到了 package.json 中, 所以如果你要改eslint配置, 是去 package.json 中去改</p>
<figure data-type="image" tabindex="26"><img src="https://lucas-y.github.io//post-images/1610681069408.png" alt="" loading="lazy"></figure>
<h2 id="配置演示">配置演示</h2>
<p>如果声明了一个变量, 未使用, 就会报错</p>
<figure data-type="image" tabindex="27"><img src="https://lucas-y.github.io//post-images/1610681093123.png" alt="" loading="lazy"></figure>
<p>这个配置, 我不想要, 我不希望报错 (你在定制你自己的eslint规则了)</p>
<p>https://eslint.bootcss.com/docs/rules/</p>
<ul>
<li>&quot;off&quot; or 0 - 关闭规则</li>
<li>&quot;warn&quot; or 1 - 将规则视为一个警告（不会影响退出码）,只警告，不会退出程序</li>
<li>&quot;error&quot; or 2 - 将规则视为一个错误 (退出码为1)，报错并退出程序</li>
</ul>
<p>自定义eslint规则</p>
<figure data-type="image" tabindex="28"><img src="https://lucas-y.github.io//post-images/1610681114471.png" alt="" loading="lazy"></figure>
<h1 id="vue2工程化环境开发">Vue2工程化环境开发</h1>
<h2 id="使用-appvue-渲染-indexhtml">使用 App.vue 渲染 index.html</h2>
<p>1 新建 App.vue</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;我是app组件&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {

}
&lt;/script&gt;

&lt;style&gt;

&lt;/style&gt;
</code></pre>
<p>2 改写 main.js</p>
<pre><code class="language-js">// 需求: 使用 App.vue 渲染 index.html
// vue3的写法
// import { createApp } from 'vue'
// import App from './App.vue'
// const app = createApp(App)
// app.mount('#app')

// vue2的写法
import Vue from 'vue'
import App from './App.vue'

new Vue({
  render: (createElement) =&gt; {
    return createElement(App)
  }
}).$mount('#app')
</code></pre>
<h2 id="体验-vue-router-3x-vue2">体验 vue-router 3.x (vue2)</h2>
<p>1 vue-router4.x (vue3)语法回顾</p>
<pre><code class="language-jsx">// 1 导入包
import { createRouter, createWebHashHistory } from 'vue-router'

// 2 创建路由模块
const router = createRouter({
  history: createWebHashHistory(),
  routes: []
})

// 3 导出路由
export default router


// ---------------------------------------------------------------
// main.js
app.use(router)
</code></pre>
<p>2 体验vue-router3.x</p>
<ul>
<li>准备 router-link 导航链接</li>
<li>准备 router-view 路由出口</li>
<li>准备 router 模块, 配置路由规则</li>
</ul>
<p>1 <code>App.vue</code> 准备导航链接, 路由出口</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;!-- 导航链接 --&gt;
    &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt; &amp;nbsp;
    &lt;router-link to=&quot;/list&quot;&gt;列表页&lt;/router-link&gt; &amp;nbsp;
    &lt;router-link to=&quot;/product&quot;&gt;商品页&lt;/router-link&gt; &amp;nbsp;

    &lt;!-- 路由出口 --&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>2 新建组件, 在<code>router/index.js</code> 路由模块创建路由</p>
<pre><code class="language-jsx">// 导包
import Vue from 'vue'
import VueRouter from 'vue-router'

import Home from '../views/home.vue'
import List from '../views/list.vue'
import Product from '../views/product.vue'

Vue.use(VueRouter)

const router = new VueRouter({
  routes: [
    { path: '/home', component: Home },
    { path: '/list', component: List },
    { path: '/product', component: Product }
  ]
})

export default router
</code></pre>
<p>3 挂载到 vue 实例上</p>
<pre><code class="language-jsx">// vue2的写法
import Vue from 'vue'
import App from './App.vue'
import router from './router'

new Vue({
  render: h =&gt; h(App),
  router
}).$mount('#app')
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vueRouter]]></title>
        <id>https://lucas-y.github.io/post/vuerouter/</id>
        <link href="https://lucas-y.github.io/post/vuerouter/">
        </link>
        <updated>2021-01-15T02:41:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前端路由">前端路由</h1>
<h2 id="spa-和-前端路由">SPA  和 前端路由</h2>
<p>SPA: 单页应用程序，一个web网站就一个页面,  所有组件的展示与切换都在这唯一的一个页面内完成。</p>
<p>此时，<code>不同组件之间的切换</code> 需要通过 <code>前端路由</code> 来实现。</p>
<p>前端路由:  <code>Hash 地址</code> 与 <code>组件</code> 之间的 <code>对应关系</code> 。</p>
<figure data-type="image" tabindex="1"><img src="https://lucas-y.github.io//post-images/1610678516051.png" alt="" loading="lazy"></figure>
<h2 id="前端路由-工作模式原理-手写">前端路由 - 工作模式原理 (手写)</h2>
<p>基本思路:</p>
<ol>
<li>用户点击了页面上的路由链接</li>
<li>导致了 URL 地址栏中的 Hash 值发生了变化</li>
<li>前端路由监听了到 Hash 地址的变化</li>
<li>前端路由把当前 Hash 地址对应的组件渲染都浏览器中</li>
</ol>
<p>实现简单的前端路由:</p>
<ol>
<li>导入并注册 <code>my-home.vue</code>  <code>my-movie</code>  <code>my-about</code> 三个组件</li>
</ol>
<pre><code class="language-html">&lt;script&gt;
import MyAbout from './components/my-about.vue'
import MyHome from './components/my-home.vue'
import MyMovie from './components/my-movie.vue'
export default {
  components: {
    MyHome,
    MyAbout,
    MyMovie
  }
}
&lt;/script&gt;
</code></pre>
<ol start="2">
<li>通过 comName 动态组件, 控制要显示的组件</li>
</ol>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;App组件&lt;/h1&gt;
    &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import MyAbout from './components/my-about.vue'
import MyHome from './components/my-home.vue'
import MyMovie from './components/my-movie.vue'
export default {
  data () {
    return {
      comName: 'my-home'
    }
  },
  components: {
    MyHome,
    MyAbout,
    MyMovie
  }
}
&lt;/script&gt;
</code></pre>
<ol start="3">
<li>声明三个导航链接, 点击时修改地址栏的 hash 值</li>
</ol>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;App组件&lt;/h1&gt;
    &lt;a href=&quot;#/home&quot;&gt;首页&lt;/a&gt;&amp;nbsp;
    &lt;a href=&quot;#/movie&quot;&gt;电影&lt;/a&gt;&amp;nbsp;
    &lt;a href=&quot;#/about&quot;&gt;关于&lt;/a&gt;&amp;nbsp;
    &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<ol start="4">
<li>在 created 中, 监视地址栏 hash 时的变化, 一旦变化, 动态切换展示的组件</li>
</ol>
<pre><code class="language-jsx">created () {
  window.onhashchange = () =&gt; {
    console.log(location.hash)
    switch(location.hash) {
      case '#/home':
        this.comName = 'my-home'
        break
      case '#/movie':
        this.comName = 'my-movie'
        break
      case '#/about':
        this.comName = 'my-about'
        break
    }
  }
},
</code></pre>
<h1 id="vue-router">vue-router</h1>
<p>vue-router 是 vue.js 官方给出的路由解决方案。它能够轻松的管理 SPA 项目中组件的切换。</p>
<h2 id="vue-router-的版本说明">vue-router 的版本说明</h2>
<p>vue-router 目前有 <code>3.x</code> 的版本和 <code>4.x</code> 的版本。其中：</p>
<ol>
<li><code>vue-router 3.x</code>只能结合 <code>vue2</code>进行使用</li>
<li><code>vue-router 4.x</code> 只能结合 <code>vue3</code>进行使用</li>
</ol>
<p>vue-router 3.x 的官方文档地址：https://router.vuejs.org/zh/</p>
<p>vue-router 4.x 的官方文档地址：https://next.router.vuejs.org/</p>
<h2 id="vue-router-4x-的使用步骤">vue-router 4.x 的使用步骤</h2>
<ol>
<li>在项目中安装 vue-router</li>
</ol>
<pre><code class="language-txt">yarn add vue-router@next
</code></pre>
<ol start="2">
<li>
<p>定义路由组件</p>
<p>在项目中定义 my-home.vue、my-movie.vue、my-about.vue三个组件，</p>
<p>将来要使用vue-router 来控制它们的展示与切换</p>
</li>
<li>
<p>声明链接 和 路由出口</p>
</li>
</ol>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;h1&gt;App组件&lt;/h1&gt;
    &lt;!-- 路由链接 --&gt;
    &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt;&amp;nbsp;
    &lt;router-link to=&quot;/movie&quot;&gt;电影&lt;/router-link&gt;&amp;nbsp;
    &lt;router-link to=&quot;/about&quot;&gt;关于&lt;/router-link&gt;

    &lt;!-- 路由出口 --&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<ol start="4">
<li>创建路由模块, 新建 router/index.js,  创建路由实例对象并导出</li>
</ol>
<pre><code class="language-jsx">// 1. 从vue-router中按需导入另两个方法
//    createRouter 用于创建路由的实例对象
//    createWebHashHistory 用于指定路由的工作模式 (hash 模式)

import { createRouter, createWebHashHistory } from 'vue-router'

import MyHome from '../components/my-home.vue'
import MyMovie from '../components/my-movie.vue'
import MyAbout from '../components/my-about.vue'


// 2. 创建路由实例对象
const router = createRouter({
  // 指定路由工作模式, hash模式
  history: createWebHashHistory(),
  // 指定路由规则
  routes: [
    // path 是 hash 地址, component 是要展示的组件
    { path: '/home', component: MyHome },
    { path: '/movie', component: MyMovie },
    { path: '/about', component: MyAbout }
  ]
})

// 3. 导出router实例
export default router
</code></pre>
<ol start="5">
<li>在main.js 中导入并挂载路由模块</li>
</ol>
<pre><code class="language-jsx">import { createApp } from 'vue'
import App from './App.vue'

import router from './router'

const app = createApp(App)

// 挂载路由模块, 使用app.use方法来挂载第三方的插件模块
app.use(router)

app.mount('#app')
</code></pre>
<h2 id="路由重定向">路由重定向</h2>
<p>路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 C ，从而展示特定的组件页面。</p>
<p>通过路由规则的 redirect 属性，指定一个新的路由地址，可以很方便地设置路由的重定向：</p>
<pre><code class="language-jsx">const router = createRouter({
  // 指定路由工作模式
  history: createWebHashHistory(),
  // 指定路由规则
  routes: [
    // path 是 hash 地址, component 是要展示的组件
    { path: '/', redirect: '/home' },
    { path: '/home', component: MyHome },
    { path: '/movie', component: MyMovie },
    { path: '/about', component: MyAbout }
  ]
})
</code></pre>
<h2 id="路由高亮">路由高亮</h2>
<p>可以通过如下的两种方式，将激活的路由链接进行高亮显示：</p>
<ol>
<li>使用默认的高亮 class 类</li>
<li>自定义路由高亮的 class 类</li>
</ol>
<h3 id="默认的高亮-class-类">默认的高亮 class 类</h3>
<p>被激活的路由链接，默认会添加一个叫做 <code>router-link-active</code>(模糊匹配) 和 <code>router-link-exact-active</code> (精确匹配) 的类名。</p>
<p>开发者可以使用此类名选择器，为激活的路由链接设置高亮的样式：</p>
<pre><code class="language-less">&lt;style lang=&quot;less&quot; scoped&gt;
// .router-link-active {
//   color: red;
// }

.router-link-exact-active {
  color: blue
}
&lt;/style&gt;
</code></pre>
<h3 id="自定义路由高亮的类名">自定义路由高亮的类名</h3>
<p>在创建路由的实例对象时，开发者可以基于 <code>linkActiveClass</code> 或者 <code>linkExactActiveClass</code> 属性，</p>
<p>自定义路由链接被激活时所应用的类名</p>
<pre><code class="language-jsx">// 2. 创建路由实例对象
const router = createRouter({
  // 指定路由工作模式
  history: createWebHashHistory(),
  
  // 指定被激活链接的类名
  linkActiveClass: 'active',
  linkExactActiveClass: 'exact-active',
  
  // 指定路由规则
  routes: [
    // path 是 hash 地址, component 是要展示的组件
    { path: '/', redirect: '/home' },
    { path: '/home', component: MyHome },
    { path: '/movie', component: MyMovie },
    { path: '/about', component: MyAbout }
  ]
})
</code></pre>
<h2 id="嵌套子路由">嵌套子路由</h2>
<p>一级路由下, 还可以嵌套二级路由  (一级导航下, 还可以有二级导航)</p>
<figure data-type="image" tabindex="2"><img src="https://lucas-y.github.io//post-images/1610678537013.png" alt="" loading="lazy"></figure>
<p>1 声明子路由的导航链接 和 子路由的出口</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div class=&quot;my-about&quot;&gt;
    &lt;h3&gt;我的关于&lt;/h3&gt;
    &lt;router-link to=&quot;/about/tab1&quot;&gt;tab1&lt;/router-link&gt; &amp;nbsp;
    &lt;router-link to=&quot;/about/tab2&quot;&gt;tab2&lt;/router-link&gt; &amp;nbsp;
    &lt;!-- 声明嵌套路由的路由出口 --&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>2 创建组件, 配置路由规则</p>
<pre><code class="language-jsx">import MyTab1 from '../components/my-tab1.vue'
import MyTab2 from '../components/my-tab2.vue'

// 2. 创建路由实例对象
const router = createRouter({
  // 指定路由工作模式, hash模式
  history: createWebHashHistory(),
  // 指定路由规则
  routes: [
    { path: '/', redirect: '/home' },
    { path: '/home', component: MyHome },
    { path: '/movie', component: MyMovie },
    { 
      path: '/about', 
      component: MyAbout,
      children: [
        { path: 'tab1', component: MyTab1 },
        { path: 'tab2', component: MyTab2 },
      ] 
    }
  ]
})
</code></pre>
<h2 id="动态路由匹配">动态路由匹配</h2>
<h3 id="基本使用">基本使用</h3>
<p>动态路由指的是：把 Hash 地址中可变的部分定义为参数项，从而提高路由规则的复用性。</p>
<p>在 vue-router 中使用英文的冒号（:）来定义路由的参数项。</p>
<p>思考: 有三个路由链接:</p>
<pre><code class="language-jsx">&lt;router-link to=&quot;/movie/1&quot;&gt;电影1&lt;/router-link&gt; &amp;nbsp;
&lt;router-link to=&quot;/movie/2&quot;&gt;电影2&lt;/router-link&gt; &amp;nbsp;
&lt;router-link to=&quot;/movie/3&quot;&gt;电影3&lt;/router-link&gt; &amp;nbsp;
</code></pre>
<p>配置对应的规则</p>
<pre><code class="language-js">{ path: '/movie/1', component: MyMovie },
{ path: '/movie/2', component: MyMovie },
{ path: '/movie/3', component: MyMovie },
</code></pre>
<p>动态路由匹配</p>
<pre><code class="language-jsx">{ path: '/movie/:id', component: MyMovie },
</code></pre>
<h3 id="动态路由匹配的参数">动态路由匹配的参数</h3>
<p>通过动态路由匹配的方式渲染出来的组件中，可以使用<code>$route.params</code> 对象访问到动态匹配的参数值</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;my-movie&quot;&gt;
    &lt;h3&gt;我的电影 - {{ $route.params.id }}&lt;/h3&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h3 id="使用-props-接收路由参数了解">使用 props 接收路由参数(了解)</h3>
<p>为了简化路由参数的获取形式，vue-router 允许在路由规则中开启props 传参。</p>
<pre><code class="language-jsx">{ path: '/movie/:id', component: MyMovie, props: true }
</code></pre>
<p>通过 props 即可拿到路由参数</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div class=&quot;my-movie&quot;&gt;
    &lt;h3&gt;我的电影 - {{ $route.params.id }}&lt;/h3&gt;
    &lt;h3&gt;我的电影 - {{ id }}&lt;/h3&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: ['id'],
  created () {
    console.log(this.$route.params.id)
  }
}
&lt;/script&gt;
</code></pre>
<h2 id="编程式导航">编程式导航</h2>
<h3 id="编程式导航的基本理解">编程式导航的基本理解</h3>
<p>编程式导航: <code>通过 js 的方式</code>, 调用 api 实现导航跳转的方式, 叫做 <code>编程式导航</code></p>
<p>声明式导航:  通过 <code>点击 router-link 链接</code> 实现导航跳转的方式, 叫做 <code>声明式导航</code></p>
<p>类比:</p>
<ul>
<li>普通网页中点击 <code>&lt;a&gt;</code> 链接属于声明式导航</li>
<li>普通网页中调用 <code>location.href</code>跳转到新页面的方式，属于编程式导航</li>
</ul>
<h3 id="编程式导航的语法">编程式导航的语法</h3>
<p>vue-router 提供了许多编程式导航的 API，其中最常用的两个 API</p>
<ol>
<li>this.$router.push('地址')  跳转地址</li>
<li>this.$router.go(-1)   实现导航地址的后退 (返回上一页)</li>
</ol>
<p><code>my-home.vue</code></p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div class=&quot;my-home&quot;&gt;
    &lt;h3&gt;我的首页&lt;/h3&gt;
    &lt;button @click=&quot;fn&quot;&gt;去movie3&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  methods: {
    fn () {
      this.$router.push('/movie/3')
    }
  }
}
&lt;/script&gt;
</code></pre>
<p><code>my-movie.vue</code></p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div class=&quot;my-movie&quot;&gt;
    &lt;h3&gt;我的电影 - {{ $route.params.id }}&lt;/h3&gt;
    &lt;h3&gt;我的电影 - {{ id }}&lt;/h3&gt;
    &lt;button @click=&quot;handleBack&quot;&gt;返回&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: ['id'],
  created () {
    console.log(this.$route.params.id)
  },
  methods: {
    handleBack () {
      this.$router.go(-1)
    }
  }
}
&lt;/script&gt;
</code></pre>
<h2 id="命名路由">命名路由</h2>
<p>通过 name 属性, 可以给路由规则起个名字, 将来可以直接更方便的,  通过 name 进行 push 跳转</p>
<p>注意: 命名路由的 <code>name值不能重复, 必须保证唯一性</code></p>
<pre><code class="language-jsx">{ path: '/movie/:id', component: MyMovie, props: true, name: 'movie' },
{ 
  path: '/about', 
  component: MyAbout,
  children: [
    { path: '', redirect: '/about/tab1' },
    { path: 'tab1', component: MyTab1, name: 'tab1' },
    { path: 'tab2', component: MyTab2, name: 'tab2' },
  ] 
}
</code></pre>
<p>跳转写法</p>
<pre><code class="language-jsx">// this.$router.push({
//   name: 'tab1'
// })
// this.$router.push({
//   name: 'tab2'
// })

this.$router.push({
  name: 'movie',
  params: {
    id: 3
  }
})
</code></pre>
<p><strong>tips</strong>: 声明式导航中, 也可以使用命名路由,  但是 to 要指定成对象, 需要 v-bind:to 来进行设置</p>
<pre><code class="language-jsx">&lt;router-link :to=&quot;{ name: 'movie', params: { id: 2 } }&quot;&gt;去movie2&lt;/router-link&gt;
&lt;router-link :to=&quot;{ name: 'tab1' }&quot;&gt;去tab1&lt;/router-link&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[组件高级]]></title>
        <id>https://lucas-y.github.io/post/zu-jian-gao-ji/</id>
        <link href="https://lucas-y.github.io/post/zu-jian-gao-ji/">
        </link>
        <updated>2021-01-15T02:25:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="watch-侦听器-监视器">watch - 侦听器 (监视器)</h1>
<p>watch 侦听器允许开发者监视数据的变化，从而针对数据的变化做特定的操作。</p>
<p>例如，监视用户名的变化并发起请求，判断用户名是否可用。</p>
<h2 id="基本语法">基本语法</h2>
<p>开发者需要在 watch 节点下，定义自己的侦听器。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;watch-demo&quot;&gt;
    用户名: &lt;input type=&quot;text&quot; v-model=&quot;username&quot;&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data () {
    return {
      username: ''
    }
  },
  watch: {
    // 监视 username 数据的变化
    // 第一个参数 新值, 第二个参数 旧值
    username (newValue, oldValue) {
      console.log(newValue, oldValue)
    }
  }
}
&lt;/script&gt;
</code></pre>
<h2 id="发送请求检测用户名是否存在">发送请求检测用户名是否存在</h2>
<p>监听 username 值的变化，并使用 axios 发起 Ajax 请求，检测当前输入的用户名是否可用：</p>
<p>axios 是一个用于发送 ajax 的工具包</p>
<p>1 安装 axios</p>
<pre><code class="language-txt">yarn add axios
</code></pre>
<p>2 导入 axios</p>
<pre><code class="language-jsx">import axios from 'axios'
</code></pre>
<p>3 发送请求</p>
<p>​    地址: https://www.escook.cn/api/finduser/:用户名  (get请求)</p>
<pre><code class="language-jsx">watch: {
  // 监视 username 数据的变化
  // 第一个参数 新值, 第二个参数 旧值
  async username (newValue, oldValue) {
    const res = await axios.get(`https://www.escook.cn/api/finduser/${newValue}`)
    console.log(res.data.message)
  }
}
</code></pre>
<h2 id="immediate-选项">immediate 选项</h2>
<p>默认情况下，组件在初次加载完毕后不会调用 watch 侦听器。</p>
<p>如果想让 watch 侦听器立即被调用，可以使用 immediate 选项。</p>
<p>需要改写成 watch 的完整写法</p>
<pre><code class="language-vue">&lt;script&gt;
import axios from 'axios'
export default {
  data () {
    return {
      username: 'abc'
    }
  },
  watch: {
    // 监视 username 数据的变化
    // 第一个参数 新值, 第二个参数 旧值
    // async username (newValue, oldValue) {
    //   const res = await axios.get(`https://www.escook.cn/api/finduser/${newValue}`)
    //   console.log(res.data.message)
    // }
    username: {
      // // 组件第一次被渲染, 就会立即出发一次侦听器
      immediate: true,
      async handler (newValue, oldValue) {
        const res = await axios.get(`https://www.escook.cn/api/finduser/${newValue}`)
        console.log(res.data.message) 
      }
    }
  }
}
&lt;/script&gt;
</code></pre>
<h2 id="deep-选项">deep 选项</h2>
<p>如果 watch 侦听的是一个对象，默认监视的是对象地址,  如果对象中的属性值发生了变化，则无法被监听到。</p>
<p>此时需要使用 deep 选项, 深度监视</p>
<pre><code class="language-jsx">data () {
  return {
    obj: {
      name: 'zs',
      age: 18
    }
  }
},
watch: {
  obj: {
    immediate: true,
    deep: true,
    handler(newValue) {
      console.log(newValue)
    }
  }
}
</code></pre>
<h2 id="监听单个属性的变化">监听单个属性的变化</h2>
<p>如果加上 deep, 默认监视的是对象, 全部属性的变化, 如果仅仅希望监视对象的某个属性的变化, 代码如下:</p>
<pre><code class="language-jsx">data () {
  return {
    obj: {
      name: 'zs',
      age: 18
    }
  }
},
watch: {
  'obj.name': {
    immediate: true,
    deep: true,
    handler(newValue) {
      console.log(newValue)
    }
  }
}
</code></pre>
<h1 id="生命周期">生命周期</h1>
<h2 id="研究生命周期的意义">研究生命周期的意义</h2>
<p>生命周期 =&gt; 一个事物从出生 到 消亡的全部过程</p>
<p>生命周期（Life Cycle）是指一个组件从<code>创建</code>-&gt; <code>运行</code> -&gt; <code>销毁</code>的整个阶段，强调的是一个时间段</p>
<ul>
<li>张三出生，表示这个人生命周期的开始</li>
<li>张三离世，表示这个人生命周期的结束</li>
<li>中间张三的一生，就是张三的生命周期</li>
</ul>
<p>我们可以把<code>每个 vue 组件运行的过程</code>，也概括为生命周期：</p>
<ul>
<li>vue 组件的初始化，表示生命周期的开始</li>
<li>vue 组件的销毁，表示生命周期的结束</li>
<li>vue 组件中间运行的过程，就是组件的生命周期</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://lucas-y.github.io//post-images/1610677589633.png" alt="" loading="lazy"></figure>
<p>研究生命周期, 可以在不同阶段, 做一些事情, 影响当前实例(组件)</p>
<h2 id="生命周期函数钩子函数">生命周期函数(钩子函数)</h2>
<p><strong>生命周期函数：是由 vue 框架提供的内置函数，会伴随着组件的生命周期，自动按次序执行。</strong></p>
<p>生命周期函数的作用：允许程序员在<code>特定的时间点</code>，执行某些特定的操作。</p>
<p>例如，组件创建完毕后，可以在created 生命周期函数中发起Ajax 请求，从而初始化 data 数据。</p>
<p>注意：<code>生命周期</code>强调的是时间段，<code>生命周期函数</code>强调的是时间点。  (比如: 人到六七岁要上小学,  六七岁出去演电影...)</p>
<h2 id="组件生命周期分类">组件生命周期分类</h2>
<p>vue 组件的生命周期函数，可以分为 3 大类：</p>
<ul>
<li>组件<code>初始化阶段</code>的生命周期函数</li>
<li>组件<code>运行阶段</code>的生命周期函数</li>
<li>组件<code>销毁阶段</code>的生命周期函数</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://lucas-y.github.io//post-images/1610677612422.png" alt="" loading="lazy"></figure>
<p><code>小 tips</code>: vue2的销毁阶段 =&gt; beforeDestroy 和 destroyed 在 vue3 已被更名为 beforeUnmount 和 unmounted</p>
<h2 id="生命周期图解">生命周期图解</h2>
<p>可以参考 vue 官方文档给出的“生命周期图示”，进一步理解组件生命周期执行的过程：</p>
<p>官网图解: <a href="https://www.vue3js.cn/docs/zh/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">地址</a></p>
<h2 id="分析组件的创建时机">分析组件的创建时机</h2>
<p>每个组件, 都有着自己的生命周期, 当组件被当成标签形式使用, 将来要渲染到页面中时, 这个组件就会被创建</p>
<pre><code class="language-jsx">&lt;jack&gt;&lt;/jack&gt;  // 创建一次

&lt;jack&gt;&lt;/jack&gt;  // 创建一次

&lt;jack&gt;&lt;/jack&gt;  // 创建一次
</code></pre>
<p>组件如果被使用三次, 那么这里有三个jack组件, 互相的生命周期互不影响</p>
<p><code>小tips</code>: 分析了解, 父子组件生命周期的关系 (了解)</p>
<figure data-type="image" tabindex="3"><img src="https://lucas-y.github.io//post-images/1610677643026.png" alt="" loading="lazy"></figure>
<p><code>小tips</code>: 利用 v-if,  控制组件的显示隐藏, 分析组件的创建和销毁</p>
<h1 id="mixin-混入">mixin 混入</h1>
<h2 id="什么是-mixin-混入">什么是 mixin 混入</h2>
<p>如果多个组件之间存在可以复用的功能，则可以把功能封装为 mixin，并混入到每个需要的组件中。</p>
<figure data-type="image" tabindex="4"><img src="https://lucas-y.github.io//post-images/1610677686635.png" alt="" loading="lazy"></figure>
<h2 id="定义-mixin">定义 mixin</h2>
<p>mixin 本质上就是一个 .js 文件，里面定义了组件之间可复用的业务逻辑，示例代码如下:</p>
<pre><code class="language-jsx">export default {
  // 可以写组件的任意配置项, data methods, 钩子函数, ...
  created () {
    this.hello()
  },
  methods: {
    hello () {
      console.log('你好, 欢迎欢迎')
    }
  }
}
</code></pre>
<h2 id="为组件混入-mixin">为组件混入 mixin</h2>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;组件1&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import hello from '../mixins/hello.js'
export default {
  mixins: [hello]
}
&lt;/script&gt;
</code></pre>
<h2 id="mixin的选项合并原则">mixin的选项合并原则</h2>
<p>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。</p>
<p>最主要的 3 个合并规则如下：</p>
<ul>
<li>data 数据的合并</li>
<li>生命周期函数的合并</li>
<li>其它选项的合并</li>
</ul>
<p><strong>1 data 数据的合并</strong>:</p>
<p>data数据项会进行合并, 如果 mixin 中的 data 数据项和组件中的 data 数据项名称冲突时，则以组件的数据项为准</p>
<p><strong>2 生命周期函数的合并:</strong></p>
<p>同名的生命周期函数将合并为一个数组(底层)，因此都会被调用。</p>
<p>而且，mixin 的生命周期函数会优先于组件的生命周期函数被调用。   (created的时候, 执行两个函数 [mixin先, 组件内的后] )</p>
<p><strong>3 其它选项的合并:</strong></p>
<p>值为对象的选项，例如 methods、components，将被合并为同一个对象。</p>
<p>两个对象键名冲突时，取组件对象的键值对（组件的优先级高）。</p>
<h1 id="组件之间的数据共享组件通信">组件之间的数据共享(组件通信)</h1>
<p>组件之间的数据, 是独立, 无法互相直接共享的, 需要通过一些语法, 实现组件数据通信</p>
<p>在项目开发中，按照通信语法, 组件之间的关系分为如下 3 种：</p>
<ul>
<li>父子关系</li>
<li>非父子关系 (常见解决兄弟关系)    通信用的语法是一样的</li>
<li>后代关系</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://lucas-y.github.io//post-images/1610677728315.png" alt="" loading="lazy"></figure>
<h2 id="父子组件的数据共享-重要">父子组件的数据共享 (重要)</h2>
<p>父子组件之间的数据共享又分为:</p>
<ul>
<li>
<p>父 -&gt; 子共享数据 (父传子)</p>
<p>1 给子组件添加属性的方式传值</p>
<p>2 子组件内, 利用 props 接收父组件传值</p>
</li>
<li>
<p>子 -&gt; 父共享数据 (子传父)</p>
<p>1 在子组件中, 通过触发事件, 传值, this.$emit(事件名, 参数1, 参数2, ...)</p>
<p>2 在父组件中, 给子组件注册对应的事件, 接收参数</p>
</li>
</ul>
<h2 id="兄弟组件非父子数据共享">兄弟组件(非父子)数据共享</h2>
<h3 id="基本说明">基本说明</h3>
<p>在 <code>vue2.x</code>中，兄弟组件之间数据共享的方案是EventBus</p>
<p>在 <code>vue3.x</code>中 EventBus 方案被剔除了。使用 mitt 作为 EventBus 的替代方案。 (原理步骤, 基本一致)</p>
<p>事件总线, 可以解决兄弟组件(非父子)组件的通信问题</p>
<figure data-type="image" tabindex="6"><img src="https://lucas-y.github.io//post-images/1610677762818.png" alt="" loading="lazy"></figure>
<p>买房卖房:</p>
<p>三个人:  买房子的人,  卖房子的人,  中介(售楼小姐)</p>
<p>现况:</p>
<ol>
<li>没有现房, B(买房子的人) 也不会一直傻乎乎在售楼处等, 会告诉售楼小姐, 他的需求   (<code>给事件总线 - 添加监听</code>)</li>
<li>售楼小姐, 会有一个小本子, 记录着要买房的人, 以及买房的需求</li>
<li>A (卖房子的人)  想卖房子,  会和售楼小姐说, 想要卖房 (发布了卖房子的消息)   (<code>给事件总线-触发事件, 发布消息</code>)</li>
<li>一旦消息发布,  售楼小姐, 会立刻根据之前记录的情况, 通知到有记录的买房者</li>
</ol>
<h3 id="使用步骤">使用步骤</h3>
<p>1 安装 mitt 包</p>
<pre><code>yarn add mitt
</code></pre>
<p>2 在 <code>components</code> 新建 <code>eventBus.js</code>,   创建公共的 eventBus 对象, 并导出</p>
<pre><code class="language-jsx">// 导入 mitt 模块
import mitt from 'mitt'

// 创建 mitt 实例对象
const emitter = mitt()

// 将 mitt 实例导出
export default emitter
</code></pre>
<p>3 在数据发送方, 给 eventBus 触发事件, 传递参数  (参数只能传一个, 如果要传多个, 可以传对象)</p>
<pre><code class="language-jsx">emmitter.emit('事件名', 参数)
</code></pre>
<p>4 在数据接收方, 给 eventBus  注册事件, 接收参数</p>
<pre><code class="language-js">emmitter.on('事件名', (参数) =&gt; {
	...
})
</code></pre>
<h3 id="了解-vue2-中的-eventbus">了解 vue2 中的 eventBus</h3>
<p>1 创建 eventBus (一个空的vue实例)</p>
<pre><code class="language-jsx">import Vue from 'vue'
const eventBus = new Vue()
export default eventBus
</code></pre>
<p>2 在数据发送方, 给 eventBus 触发事件, 传递参数</p>
<pre><code class="language-jsx">eventBus.$emit('事件名', 参数)
</code></pre>
<p>3 在数据接收方, 给 eventBus  注册事件, 接收参数</p>
<pre><code class="language-js">eventBus.$on('事件名', (参数) =&gt; {
	...
})
</code></pre>
<h2 id="后代关系组件之间的共享数据">后代关系组件之间的共享数据</h2>
<p>后代关系组件之间共享数据，指的是<code>父节点的组件向其子孙组件共享数据</code>。</p>
<p>此时组件之间的嵌套关系比较复杂，可以使用 provide 和 inject 实现后代关系组件之间的数据共享。</p>
<h3 id="父组件provide共享数据">父组件<code>provide</code>共享数据</h3>
<p>利用 provide 函数, 在 return 的对象中, 就包含要向子组件共享的数据</p>
<pre><code class="language-jsx">export default {
  data () {
    return {
      flag: true,
      color: 'red' // 定义父组件需要共享的数据
    }
  },
  provide () { // 利用 provide 函数, 在 return 的对象中, 就包含要向子组件共享的数据
    return {
      color: this.color
    }
  },
}
</code></pre>
<h3 id="子孙节点-inject-接收数据">子孙节点 <code>inject</code> 接收数据</h3>
<p>子孙节点可以使用 inject 数组，接收父级节点向下共享的数据</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div class=&quot;sun&quot;&gt;我是孙组件 - {{ color }}&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  inject: ['color']
}
&lt;/script&gt;
</code></pre>
<h3 id="向子孙节点共享响应式的数据">向子孙节点共享响应式的数据</h3>
<p>默认共享的数据, 如果是简单类型的, 就会是非响应式的数据</p>
<p>如果希望是响应式的, 可以向子孙节点, 共享一个对象, 对象的属性修改时, 是响应式的!</p>
<p><code>提供数据</code></p>
<pre><code class="language-js">  data () {
    return {
      // color: 'red' // 定义父组件需要共享的数据
      colorObj: {
        color: 'red'
      }
    }
  },
  provide () { // 利用 provide 函数, 在 return 的对象中, 就包含要向子组件共享的数据
    return {
      colorObj: this.colorObj
    }
  },
</code></pre>
<p><code>获取数据</code></p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div class=&quot;sun&quot;&gt;我是孙组件 - {{ colorObj.color }}&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  inject: ['colorObj']
}
&lt;/script&gt;
</code></pre>
<h2 id="组件之间的数据共享-vuex">组件之间的数据共享 vuex</h2>
<p>vuex 是组件之间的<code>数据共享方案</code>的 <code>最终奥义</code>。</p>
<p>在企业级的 vue 项目开发中，vuex 可以让组件之间的数据共享变得高效、清晰、且易于维护。</p>
<figure data-type="image" tabindex="7"><img src="https://lucas-y.github.io//post-images/1610677800877.png" alt="" loading="lazy"></figure>
<h1 id="axios-介绍">axios 介绍</h1>
<ol>
<li>
<p>axios 是什么 ?</p>
<p>就是一个 发送  ajax  请求的工具</p>
<p>axios 底层, 就是 原生 ajax, 只是它内部是通过 promise 封装的</p>
</li>
<li>
<p>axios的基本使用</p>
</li>
</ol>
<pre><code class="language-jsx">axios({
  method: '请求方式', // get post
  url: '请求地址',
  data: {    // 拼接到请求体的参数,  post请求的参数
    xxx: xxx,
  },
  params: {  // 拼接到请求行的参数, get请求的参数
   	xxx: xxx 
  }
}).then(res =&gt; {
  console.log(res.data) // 后台返回的结果
}).catch(err =&gt; {
  console.log(err)
})


axios.get(url).then(...)
axios.get(url, {
  params: {  xx: xxx  },
  headers: {}
})
                                  
axios.post(url, data).then(...)
</code></pre>
<h1 id="axios优化了解">axios优化(了解)</h1>
<h2 id="处理基地址">处理基地址</h2>
<pre><code class="language-jsx">// 配置请求根路径
axios.defaults.baseURL = 'https://www.escook.cn'
</code></pre>
<h2 id="挂载到全局">挂载到全局</h2>
<pre><code class="language-jsx">// 配置请求根路径
axios.defaults.baseURL = 'https://www.escook.cn'
// 将axios挂载为 app 的全局属性
// 挂载后, 所有的组件实例, 都可以通过 this 访问到挂载的全局属性
const app = createApp(App)
app.config.globalProperties.$http = axios
app.mount('#app')
</code></pre>
<h1 id="ref-和-refs">ref 和 $refs</h1>
<p>利用 ref 和 $refs 可以用于获取 dom 元素, 或者组件实例</p>
<p>每个 vue 的组件实例上，都包含一个$refs 对象，里面存储着对应的DOM 元素或组件的引用。</p>
<p>1 给需要获取的 dom 元素或者组件, 添加 ref 属性</p>
<pre><code class="language-jsx">&lt;div&gt;
  &lt;div ref=&quot;box&quot;&gt;我是div盒子&lt;/div&gt;
  &lt;jack ref=&quot;jack&quot;&gt;&lt;/jack&gt;
  &lt;button @click=&quot;fn&quot;&gt;按钮&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p>2 通过 <code>this.$refs.xxx</code> 获取, 拿到组件可以调用组件的方法</p>
<pre><code class="language-jsx">import Jack from './jack.vue'
export default {
  methods: {
    fn () {
      console.log(this.$refs.box)
      console.log(this.$refs.jack)
      this.$refs.jack.sayHi()
    }
  },
  components: {
    Jack
  }
}
</code></pre>
<h1 id="nexttick">$nextTick</h1>
<p><strong>需求1: 点击按钮, 切换显示输入框</strong></p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- 需求: 点击按钮, 切换显示输入框 --&gt;
    &lt;input type=&quot;text&quot; v-if=&quot;isShowInput&quot;&gt;
    &lt;button @click=&quot;fn&quot; v-else&gt;点此搜索&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data () {
    return {
      isShowInput: false
    }
  },
  methods: {
    fn () {
      this.isShowInput = true
    }
  }
}
&lt;/script&gt;
</code></pre>
<p><strong>需求2: 显示输入框的同时, 要获取焦点</strong></p>
<p>当文本框展示出来之后，如果希望它立即获得焦点，则可以为其添加 ref 引用，并调用原生 DOM 对象的.focus() 方法即可。</p>
<p>直接调用会报错, 因为 vue 是 异步dom更新的 (提升渲染效率),  <code>this.isShowInput = true</code> 执行完时, 实际的 dom 还没渲染出来</p>
<pre><code class="language-jsx">&lt;input ref=&quot;inp&quot; type=&quot;text&quot; v-if=&quot;isShowInput&quot;&gt;

fn () {
  this.isShowInput = true
  this.$refs.inp.focus()
}
</code></pre>
<p>组件的 <code>$nextTick(callback)</code> 方法，会把 callback 回调推迟到下一个 DOM 更新周期之后执行。</p>
<p>通俗的理解是：<strong>等组件的DOM 刷新之后，再执行 callback 回调函数</strong>。从而能保证 callback 函数可以操作到最新的 DOM 元素。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- 需求: 点击按钮, 切换显示输入框 --&gt;
    &lt;input ref=&quot;inp&quot; type=&quot;text&quot; v-if=&quot;isShowInput&quot;&gt;
    &lt;button @click=&quot;fn&quot; v-else&gt;点此搜索&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data () {
    return {
      isShowInput: false
    }
  },
  methods: {
    fn () {
      this.isShowInput = true
      this.$nextTick(() =&gt; {
        this.$refs.inp.focus()
      })
    }
  }
}
&lt;/script&gt;
</code></pre>
<h1 id="dynamic-动态组件">dynamic 动态组件</h1>
<h2 id="动态组件的基本使用">动态组件的基本使用</h2>
<p>什么是动态组件:   让多个组件使用同一个挂载点，并动态切换，这就是动态组件</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h3&gt;动态组件的演示&lt;/h3&gt;
    &lt;!-- 动态组件 =&gt; 多个组件使用同一个挂载点, 并可以动态的切换展示 --&gt;
    &lt;button @click=&quot;comName = 'my-swiper'&quot;&gt;swiper&lt;/button&gt;
    &lt;button @click=&quot;comName = 'my-nav'&quot;&gt;nav&lt;/button&gt;
    
    &lt;!-- 
      &lt;my-nav&gt;&lt;/my-nav&gt;
      &lt;my-swiper&gt;&lt;/my-swiper&gt; 
    --&gt;
    &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import MyNav from './my-nav.vue'
import MySwiper from './my-swiper.vue'
export default {
  data () {
    return {
      comName: 'my-nav'
    }
  },
  components: {
    MyNav,
    MySwiper
  }
}
&lt;/script&gt;
</code></pre>
<h2 id="使用-keep-alive-保持状态">使用 keep-alive 保持状态</h2>
<p>默认情况下，切换动态组件时无法保持组件的状态。会将组件销毁, 将来显示时, 又会重新创建</p>
<p>此时可以使用vue 内置的 <code>&lt;keep-alive&gt;</code> 组件保持动态组件的状态。</p>
<p>使用 keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们</p>
<pre><code class="language-jsx">&lt;keep-alive&gt;
  &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
</code></pre>
<h1 id="插槽">插槽</h1>
<p>插槽（Slot）是 vue 为组件的封装者提供的能力。</p>
<p>允许开发者在封装组件时，把不确定的、希望由用户指定的部分定义为插槽。</p>
<h2 id="默认插槽-slot">默认插槽 slot</h2>
<p><strong>需求: 要在页面中显示一个对话框, 封装成一个组件</strong></p>
<figure data-type="image" tabindex="8"><img src="https://lucas-y.github.io//post-images/1610678122099.png" alt="" loading="lazy"></figure>
<p>通过父传子, 固然可以完成一定层面的组件的定制, 但是自定义性较差,</p>
<p>如果希望能够自定义组件内部的一些结构 =&gt; 就需要用到插槽</p>
<p><strong>插槽作用: 用于实现组件的内容分发, 通过 slot 标签, 可以接收到写在组件标签内的内容</strong></p>
<p>基本示例:</p>
<pre><code class="language-jsx">&lt;my-dialog&gt;
  &lt;p&gt;请输入正确的手机号码&lt;/p&gt;
&lt;/my-dialog&gt;
</code></pre>
<p><code>my-dialog.vue</code></p>
<pre><code class="language-less">&lt;template&gt;
  &lt;div class=&quot;my-dialog&quot;&gt;
    &lt;div class=&quot;header&quot;&gt;
      &lt;h3&gt;友情提示&lt;/h3&gt;
    &lt;/div&gt;
    &lt;div class=&quot;content&quot;&gt;
      &lt;slot&gt;&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div class=&quot;footer&quot;&gt;
      &lt;button&gt;关闭&lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {

}
&lt;/script&gt;

&lt;style lang=&quot;less&quot; scoped&gt;
.my-dialog {
  width: 400px;
  padding: 10px 20px;
  border: 3px solid #000;
  border-radius: 5px;
  margin: 10px;
}
&lt;/style&gt;
</code></pre>
<h2 id="后备内容-默认值">后备内容 (默认值)</h2>
<p>封装组件时，可以为预留的 <code>&lt;slot&gt;</code> 插槽提供后备内容（默认内容）。</p>
<p>如果组件的使用者没有为插槽提供任何内容，则后备内容会生效。</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div class=&quot;my-dialog&quot;&gt;
    &lt;div class=&quot;header&quot;&gt;
      &lt;h3&gt;友情提示&lt;/h3&gt;
    &lt;/div&gt;
    &lt;div class=&quot;content&quot;&gt;
      &lt;slot&gt;这是后备内容&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div class=&quot;footer&quot;&gt;
      &lt;button&gt;关闭&lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h2 id="具名插槽">具名插槽</h2>
<h3 id="插槽的分类">插槽的分类:</h3>
<p><strong>1 默认插槽(匿名插槽)</strong></p>
<p><code>&lt;slot&gt;&lt;/slot&gt;</code> 只要没有具体分发的内容, 都会给到默认插槽</p>
<p><code>&lt;slot name=&quot;default&quot;&gt;&lt;/slot&gt;</code> 是默认插槽完整的写法 和 <code>&lt;slot&gt;&lt;/slot&gt;</code> 完全等价</p>
<p><strong>2 具名插槽: 具有名字的插槽 (配置了名字),  可以实现定向分发</strong></p>
<p>一旦配置了名字, 只会接收对应的内容, 不是分发给他的, 就不要</p>
<h3 id="具名插槽的使用步骤">具名插槽的使用步骤</h3>
<p>(1) 给插槽起名字</p>
<pre><code class="language-jsx">&lt;div class=&quot;header&quot;&gt;
  &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
  &lt;slot&gt;这是后备内容&lt;/slot&gt;
&lt;/div&gt;
&lt;div class=&quot;footer&quot;&gt;
  &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
&lt;/div&gt;
</code></pre>
<p>(2) 需要使用 template 标签, 将内容包裹成一个整体</p>
<p>(3) 通过 v-slot:插槽名, 指定具体分发给谁</p>
<pre><code class="language-html">&lt;my-dialog&gt;
  &lt;template v-slot:header&gt;
    &lt;h3&gt;这是大标题&lt;/h3&gt;
  &lt;/template&gt;

  &lt;template v-slot:default&gt;
    &lt;p&gt;这是内容&lt;/p&gt;
  &lt;/template&gt;

  &lt;template v-slot:footer&gt;
    &lt;button&gt;确认&lt;/button&gt;
    &lt;button&gt;取消&lt;/button&gt;
  &lt;/template&gt;
&lt;/my-dialog&gt;
</code></pre>
<h3 id="具名插槽的简写">具名插槽的简写</h3>
<p>跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。</p>
<p>例如 v-slot:header 可以被简写为 #header</p>
<pre><code class="language-jsx">&lt;my-dialog&gt;
  &lt;template #header&gt;
    &lt;h3&gt;这是大标题&lt;/h3&gt;
  &lt;/template&gt;

  &lt;template #default&gt;
    &lt;p&gt;这是内容&lt;/p&gt;
  &lt;/template&gt;

  &lt;template #footer&gt;
    &lt;button&gt;确认&lt;/button&gt;
    &lt;button&gt;取消&lt;/button&gt;
  &lt;/template&gt;
&lt;/my-dialog&gt;
</code></pre>
<h2 id="作用域插槽">作用域插槽</h2>
<p>作用域插槽: <strong>定义 slot 插槽的同时, 是可以传值的</strong>, 将来在分发内容时, 可以使用</p>
<ol>
<li>给 slot 标签, 以 添加属性的方式传值</li>
</ol>
<pre><code class="language-jsx">&lt;slot name=&quot;bottom&quot; :yes=&quot;yes&quot; :no=&quot;no&quot; money=&quot;100&quot;&gt;&lt;/slot&gt;
</code></pre>
<ol start="2">
<li>所有添加的属性, 都会被收集到一个对象中</li>
</ol>
<pre><code class="language-js">{ yes: '确认', no: '取消', money: '100' }
</code></pre>
<ol start="3">
<li>在template中, 通过  <code>v-slot:插槽名= &quot;obj&quot;</code> 接收</li>
</ol>
<pre><code class="language-jsx">&lt;template #bottom=&quot;obj&quot;&gt;
  &lt;!-- {{ obj }} --&gt;
  &lt;button&gt;{{ obj.yes }}&lt;/button&gt;
  &lt;button&gt;{{ obj.no }}&lt;/button&gt;
  &lt;button&gt;{{ obj.money }}&lt;/button&gt;
&lt;/template&gt;
</code></pre>
<ol start="4">
<li>可以使用解构赋值简化数据的接收</li>
</ol>
<pre><code class="language-jsx">&lt;template #bottom=&quot;{ yes, no, money }&quot;&gt;
  &lt;button&gt;{{ yes }}&lt;/button&gt;
  &lt;button&gt;{{ no }}&lt;/button&gt;
  &lt;button&gt;{{ money }}&lt;/button&gt;
&lt;/template&gt;
</code></pre>
<h1 id="自定义指令">自定义指令</h1>
<h2 id="自定义指令说明">自定义指令说明</h2>
<p>https://www.vue3js.cn/docs/zh/guide/custom-directive.html</p>
<p>除了核心功能默认内置的指令 (<code>v-model</code> 和 <code>v-show</code>)，Vue 也允许注册自定义指令。 <code>v-pengpeng</code></p>
<p>注意，代码复用和抽象的主要形式是组件。</p>
<p>然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</p>
<h2 id="自定义指令-局部注册">自定义指令 - 局部注册</h2>
<p>例如需求:  当页面加载时，让元素将获得焦点 , (autofocus 在 safari 浏览器有兼容性)</p>
<pre><code class="language-less">&lt;template&gt;
  &lt;div&gt;
    &lt;h3&gt;自定义指令&lt;/h3&gt;
    &lt;input ref=&quot;inp&quot; type=&quot;text&quot; v-focus&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  mounted () {
    // this.$refs.inp.focus()
  },
  directives: {
    // 自定义一个局部指令
    focus: {
      // 当被绑定的元素被插入到 DOM 中时, 会自动触发  vue2中inserted
      mounted (el) {
        el.focus()
      }
    }
  }
}
&lt;/script&gt;
</code></pre>
<h2 id="自定义指令-全局注册">自定义指令 - 全局注册</h2>
<pre><code class="language-jsx">import { createApp } from 'vue'
import App from './App.vue'
const app = createApp(App)

// 注册全局组件
// app.component(组件名, 组件配置项)

// 注册全局自定义指令
app.directive('focus', {
  mounted (el) {
    el.focus()
  }
})

app.mount('#app')
</code></pre>
<h2 id="自定义指令-指令的值">自定义指令 - 指令的值</h2>
<p>在绑定指令时，可以通过“等号”的形式为指令绑定具体的参数值</p>
<p>需求: v-color=&quot;color&quot; 给对应的颜色, 就能改对应的字体颜色</p>
<pre><code class="language-jsx">&lt;div v-color=&quot;color&quot;&gt;我是内容&lt;/div&gt;
</code></pre>
<p>实现:</p>
<pre><code class="language-jsx">directives: {
  // 自定义一个局部指令
  color: {
    mounted (el, binding) {
      el.style.color = binding.value
    },
    // updated指令的值改变时触发, binding.value指令的值修改触发
    updated (el, binding) {
      el.style.color = binding.value
    }
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单页应用程序-组件化]]></title>
        <id>https://lucas-y.github.io/post/vue-dan-ye-ying-yong-cheng-xu/</id>
        <link href="https://lucas-y.github.io/post/vue-dan-ye-ying-yong-cheng-xu/">
        </link>
        <updated>2021-01-13T12:25:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="单页应用程序">单页应用程序</h1>
<h2 id="单页应用程序-spa">单页应用程序 SPA</h2>
<p><strong>单页Web应用（single page web application，SPA）</strong> <strong>只有一张Web页面的应用,  所有的功能在一个页面上实现</strong></p>
<figure data-type="image" tabindex="1"><img src="https://lucas-y.github.io//post-images/1610540930245.png" alt="" loading="lazy"></figure>
<p>location.href = 'login.html'</p>
<p>多页面应用程序: 京东   https://miaosha.jd.com/</p>
<p>单页面应用程序: 网易云  https://music.163.com/   切换时, 不跳转页面</p>
<h2 id="spa-项目优缺点">SPA 项目优缺点</h2>
<p>SPA 单页面应用程序最显著的 3 个优点如下：</p>
<ol>
<li><strong>良好的交互体验</strong>
<ul>
<li><strong>单页应用的内容的改变,  不需要重新加载整个页面</strong></li>
<li>获取数据也是通过 Ajax 异步获取</li>
<li>没有页面之间的跳转 location.href ，不会出现“白屏现象”</li>
</ul>
</li>
<li>良好的前后端工作分离模式
<ul>
<li>后端专注于提供 API 接口，更易实现 API 接口的复用</li>
<li>前端专注于页面的渲染，更利于前端工程化的发展</li>
</ul>
</li>
<li>减轻服务器的压力
<ul>
<li>服务器只提供数据，不负责页面的合成与逻辑的处理，压力更小</li>
<li>每次请求, 仅仅是请求必须的内容, 效率很高,  css样式, 基本的js在第一次加载页面后, 就已经加载完了</li>
</ul>
</li>
</ol>
<p>缺点:</p>
<ul>
<li><strong>首屏加载会相对较慢</strong>, 因为一上来加载了所有的资源 (后面讲)
<ul>
<li>配置异步组件, 按需加载</li>
<li>CDN加速 (花钱加速)</li>
<li>文件压缩  (减少体积)</li>
</ul>
</li>
<li><strong>不利于 SEO</strong> 搜索引擎优化
<ul>
<li>花钱推广</li>
<li>SSR 服务器端渲染   (稍微好一点)</li>
</ul>
</li>
</ul>
<h2 id="快速创建工程化的环境">快速创建工程化的环境</h2>
<p>vue 官方提供了两种快速创建工程化的 SPA 项目的方式：</p>
<ul>
<li>基于 <strong>vite</strong> 创建 SPA 项目  (尤雨溪新作)</li>
<li>基于 <strong>vue-cli</strong> 创建 SPA 项目 (底层webpack)</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://lucas-y.github.io//post-images/1610541752100.png" alt="" loading="lazy"></figure>
<p>vite  轻量, 快,  适合进行demo的学习</p>
<p>vue-cli  =&gt;  webpack,  重, 大, 适合于企业级项目</p>
<h1 id="vite-的使用">vite 的使用</h1>
<h2 id="vite-的基本使用">vite 的基本使用</h2>
<p>按照顺序执行如下的命令，即可基于 vite 创建 vue 3.x 的工程化项目</p>
<pre><code>npm init vite-app 项目名称

cd 项目名称
yarn
yarn dev
</code></pre>
<p>输入地址, 启动项目:</p>
<figure data-type="image" tabindex="3"><img src="https://lucas-y.github.io//post-images/1610541942053.png" alt="" loading="lazy"></figure>
<h2 id="梳理项目结构">梳理项目结构</h2>
<h3 id="整体目录">整体目录</h3>
<p>使用 vite 创建的项目结构如下：</p>
<figure data-type="image" tabindex="4"><img src="https://lucas-y.github.io//post-images/1610541974883.png" alt="" loading="lazy"></figure>
<p>其中：</p>
<ul>
<li>node_modules 目录用来存放第三方依赖包</li>
<li>public 是公共的静态资源目录</li>
<li>src 是项目的源代码目录（程序员写的所有代码都要放在此目录下）</li>
<li>.gitignore 是 Git 的忽略文件</li>
<li>index.html 是 SPA 单页面应用程序中唯一的HTML 页面</li>
<li>package.json 是项目的包管理配置文件</li>
</ul>
<h3 id="src-目录介绍">src 目录介绍</h3>
<p>在 src  <strong>项目源代码目录</strong> 之下，包含了如下内容：</p>
<figure data-type="image" tabindex="5"><img src="https://lucas-y.github.io//post-images/1610545125652.png" alt="" loading="lazy"></figure>
<ul>
<li>assets 目录用来存放项目中所有的静态资源文件（css、fonts等）</li>
<li>components 目录用来存放项目中所有的自定义组件</li>
<li>App.vue 是项目的根组件</li>
<li>index.css 是项目的全局样式文件</li>
<li>main.js 是整个项目的打包入口文件</li>
</ul>
<h2 id="vite-项目运行的流程">vite 项目运行的流程</h2>
<p>在工程化的vite项目中，vue 默认做的事情很单纯：<strong>通过 main.js 把 App.vue 渲染到 index.html 的指定区域中</strong>。</p>
<p>(安装vetur插件,  <code>.vue 文件</code>高亮)</p>
<p>其中：</p>
<ul>
<li>App.vue 用来编写待渲染的模板结构</li>
<li>index.html 中需要预留一个 el 区域</li>
<li>main.js 把 App.vue 渲染到了 index.html 所预留的区域中</li>
</ul>
<pre><code class="language-jsx">import { createApp } from 'vue'
import App from './App.vue'
import './index.css'

// 将 App.vue 的内容, 渲染到 index.html中
// 1. 在 App.vue 中编写待渲染的结构
// 2. index.html 中预留一个 el 区域
// 3. main.js 将App.vue渲染到index.html的el区域

// 调用createApp()函数, 就是在创建一个单页应用实例, 通过.mount方法, 渲染到el区域中
const app = createApp(App)
app.mount('#app')
</code></pre>
<h2 id="梳理-vite-项目运行的流程">梳理 vite 项目运行的流程</h2>
<p>1 清空src目录, 新建 main.js 和 App.vue 文件</p>
<p>2 修改 App.vue 的默认内容，并书写如下的模板结构</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;h1&gt;我是App根级别组件&lt;/h1&gt;
&lt;/template&gt;
</code></pre>
<p>3 打开 index.html 页面，确认预留了 el 区域</p>
<pre><code class="language-jsx">&lt;!-- vue所管理的视图范围 --&gt;
&lt;div id=&quot;box&quot;&gt;
  &lt;!-- 这里不写任何内容, 而是通过 App.vue 组件渲染 --&gt;
&lt;/div&gt;
&lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>4 按照 vue3 的标准用法, 将 App.vue 模板内容渲染到 index.html 页面的 el 区域中</p>
<pre><code class="language-jsx">// 1. 从 vue 中按需导入 createApp 函数
//    createApp 函数的作用: 可以创建 vue 的单页应用实例
import { createApp } from 'vue'

// 2. 导入待渲染的 App 组件
import App from './App.vue'

// 3. 调用 createApp () 函数, 创建 单页应用程序实例
const app = createApp(App)

// 4. 调用 实例的 .mount 方法, 指定vue要控制的视图区域
app.mount('#box')
</code></pre>
<p>注意: template 仅仅是一个包裹容器, 不会生成任何实质性的结构</p>
<h1 id="组件化开发">组件化开发</h1>
<h2 id="什么是组件化开发">什么是组件化开发</h2>
<p><strong>组件化开发</strong> 指的是：根据封装的思想，把页面上 <code>可重用的部分</code> 封装为 <code>组件</code>，从而方便项目的 开发 和 维护。</p>
<p><strong>一个页面， 可以拆分成一个个组件，一个组件就是一个整体, 每个组件可以有自己独立的 结构 样式 和 行为</strong></p>
<p>例如：http://www.ibootstrap.cn/ 所展示的效果，就契合了组件化开发的思想。</p>
<p>用户可以通过拖拽组件的方式，快速生成一个页面的布局结构。</p>
<p>前端组件化开发的好处主要体现在以下两方面：</p>
<ul>
<li>
<p>提高了前端代码的<strong>复用性和灵活性</strong></p>
</li>
<li>
<p>提升了开发效率和后期的<strong>可维护性</strong></p>
</li>
</ul>
<p>vue 是一个完全支持组件化开发的框架。vue 中规定组件的后缀名是 .vue。</p>
<p>之前接触到的 App.vue 文件本质上就是一个 vue 的组件。</p>
<h2 id="单文件组件的三大组成部分">单文件组件的三大组成部分</h2>
<p>每个 .vue 组件都由 3 部分构成，分别是：</p>
<ul>
<li>template -&gt; 组件的模板结构</li>
<li>script -&gt; 组件的 JavaScript 行为</li>
<li>style -&gt; 组件的样式</li>
</ul>
<p>其中，<strong>每个组件中必须包含 template 模板结构</strong>，而 script 行为和 style 样式是可选的组成部分。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;h1&gt;我是App根级别组件&lt;/h1&gt;
&lt;/template&gt;

&lt;script&gt;
// 在script中, 需要默认导出一个组件的配置对象
export default {
  
}
&lt;/script&gt;

&lt;style&gt;
h1 {
  color: red;
}
&lt;/style&gt;
</code></pre>
<p>该组件可以在其他文件中导入, <strong>注意导入的是整个整体</strong></p>
<pre><code class="language-jsx">// 导入 App 组件 (结构 样式 行为)
import App from './App.vue'
</code></pre>
<h2 id="组件的-template-说明">组件的 template 说明</h2>
<p>每个组件对应的 <code>模板结构</code>，需要定义到 <code>&lt;template&gt;</code> 节点中。</p>
<p>注意：</p>
<ol>
<li>
<p><code>&lt;template&gt;</code> 是 vue 提供的容器标签，只起到包裹性质的作用，它不会被渲染为真正的 DOM 元素。</p>
</li>
<li>
<p>在 template 定义根节点 (了解)</p>
<p>在 vue 3.x 的版本中，<code>&lt;template&gt;</code> 节点内的 DOM 结构支持多个根节点。</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;h1&gt;我是App根级别组件&lt;/h1&gt;
  &lt;h1&gt;我是另外一个根节点&lt;/h1&gt;
&lt;/template&gt;
</code></pre>
<p>但是，在 vue 2.x 的版本中，<code>&lt;template&gt;</code>节点内的 DOM 结构仅支持单个根节点，不支持多个根节点</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;h1&gt;我是App根级别组件&lt;/h1&gt;
&lt;/template&gt;
</code></pre>
</li>
</ol>
<h2 id="组件的-script-说明">组件的 script 说明</h2>
<p>组件内的 <code>&lt;script&gt;</code>节点是可选的，开发者可以在 <code>&lt;script&gt;</code>节点中封装组件的 JavaScript 业务逻辑。</p>
<pre><code class="language-html">&lt;script&gt;
// 在script中, 需要默认导出一个组件的配置对象
export default {
  
}
&lt;/script&gt;
</code></pre>
<p><strong>1 script 中的 <code>name</code> 节点</strong></p>
<p>可以通过 name 节点为当前组件定义一个名称：</p>
<pre><code class="language-jsx">export default {
  name: 'MyApp'
}
</code></pre>
<p>在使用 vue-devtools 进行项目调试的时候，自定义的组件名称可以清晰的区分每个组件：</p>
<figure data-type="image" tabindex="6"><img src="https://lucas-y.github.io//post-images/1610547044968.png" alt="" loading="lazy"></figure>
<p><strong>2 scripts 中的 <code>data</code> 节点</strong></p>
<p>vue 组件渲染期间需要用到的数据，可以定义在data 节点中：</p>
<pre><code class="language-jsx">export default {
  name: 'MyApp',
  data () {
    return {
      username: '嘎嘎'
    }
  }
}
</code></pre>
<p>vue中规定: <strong>组件中的 data 必须是函数,</strong> 不能直接指向一个数据对象。</p>
<p>因此在组件中定义 data 数据节点时，下面的方式是错误的：</p>
<pre><code class="language-jsx">data: {
  count: 0  // 错误, 不能让 data 指向一个数据对象
}
</code></pre>
<p>会导致多个组件实例共用同一份数据的问题，请参考官方给出的示例：<a href="https://cn.vuejs.org/v2/guide/components.html#data-%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0">官网地址</a></p>
<p><strong>3 script 中的 <code>methods</code> 节点</strong></p>
<p>组件中的处理函数，要声明到 methods 节点中，示例代码如下:</p>
<pre><code class="language-jsx">export default {
  name: 'MyApp',
  data () {
    return {
      username: '嘎嘎'
    }
  },
  methods: {
    fn () {
      console.log('123')
    }
  }
}
</code></pre>
<h2 id="组件的-style-说明">组件的 style 说明</h2>
<h3 id="基本说明">基本说明</h3>
<p>组件内的 <code>&lt;style&gt;</code> 节点是可选的，开发者可以在 <code>&lt;style&gt;</code>节点中编写样式美化当前组件的 UI 结构</p>
<p>其中 <code>&lt;style&gt;</code>标签上的 lang=&quot;css&quot; 属性是可选的，它表示所使用的样式语言。</p>
<p>默认只支持普通的 css 语法，可选值还有 less、sass/scss 、 stylus等。</p>
<pre><code class="language-css">&lt;style lang=&quot;css&quot;&gt;
h1 {
  color: blue;
}
&lt;/style&gt;
</code></pre>
<h3 id="让-style-中支持-less-语法">让 style 中支持 less 语法</h3>
<p>如果希望使用 less 语法编写组件的 style 样式，可以按照如下两个步骤进行配置：</p>
<ul>
<li>运行 yarn add less -D 命令安装依赖包，从而提供 less 语法的编译支持</li>
<li>在 <code>&lt;style&gt;</code> 标签上添加 <code>lang=&quot;less&quot;</code>属性，即可使用 less 语法编写组件的样式</li>
</ul>
<pre><code>&lt;style lang=&quot;less&quot;&gt;
@color: red;
div {
  color: @color;
}
&lt;/style&gt;
</code></pre>
<h2 id="组件的注册">组件的注册</h2>
<p>刚才我们创建使用的是 App.vue 根组件, 这个比较特殊, 是最大的一个根组件</p>
<p>而App.vue根组件内, 还可以写入一些小组件, 而这些组件, 要使用, 就需要先注册!</p>
<figure data-type="image" tabindex="7"><img src="https://lucas-y.github.io//post-images/1610547112428.png" alt="" loading="lazy"></figure>
<p><strong>注册组件有两种注册方式</strong>:  分为“全局注册”和“局部注册”两种</p>
<ul>
<li>被全局注册的组件，可以在任意的组件模板范围中使用          (每个组件都是一个vue实例)</li>
<li>被局部注册的组件，只能在当前注册的组件模板范围内使用</li>
</ul>
<h3 id="全局组件">全局组件</h3>
<p>全局注册: 被全局注册的组件，可以在任意的组件模板范围中使用</p>
<p>1 新建 components 文件夹, 准备三个文件 <code>hm-header.vue</code>    <code>hm-main.vue</code>    <code>hm-footer.vue</code></p>
<pre><code class="language-less">&lt;template&gt;
  &lt;div class=&quot;hm-header&quot;&gt;头部&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {

}
&lt;/script&gt;

&lt;style lang=&quot;less&quot;&gt;
.hm-header {
  height: 50px;
  border: 3px solid #000;
  padding: 20px;
  margin-bottom: 20px;
}
&lt;/style&gt;
</code></pre>
<p>2 在 <code>main.js</code> 中导入</p>
<pre><code class="language-jsx">// .vue文件中, 提供了组件的配置项, 将来基于这个配置项, 可以注册组件, 就可以当成html标签使用
import HmHeader from './components/hm-header.vue'
</code></pre>
<p>3 全局注册</p>
<pre><code class="language-jsx">// 全局注册组件
app.component('hm-header', HmHeader)
</code></pre>
<p>4 使用组件 =&gt;  注册好的组件, 可以当成 html 标签使用</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;hm-header&gt;&lt;/hm-header&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://lucas-y.github.io//post-images/1610547150224.png" alt="" loading="lazy"></figure>
<h3 id="局部注册">局部注册</h3>
<p>局部注册: 被局部注册的组件，只能在当前注册的组件模板范围内使用</p>
<p>1 在 App.vue 中导入</p>
<pre><code class="language-jsx">import HmHeader from './components/hm-header.vue'
import HmMain from './components/hm-main.vue'
import HmFooter from './components/hm-footer.vue'
</code></pre>
<p>2 局部注册</p>
<pre><code class="language-jsx">export default {
  name: 'MyApp',
  components: {
    'hm-header': HmHeader,
    'hm-main': HmMain,
    'hm-footer': HmFooter
  }
}
</code></pre>
<p>3 使用局部注册的组件</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;hm-header&gt;&lt;/hm-header&gt;
    &lt;hm-main&gt;&lt;/hm-main&gt;
    &lt;hm-footer&gt;&lt;/hm-footer&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h3 id="组件名的大小写">组件名的大小写</h3>
<p>在进行组件的注册时，定义组件名的方式有两种：</p>
<ul>
<li>
<p>注册使用短横线命名法，例如 hm-header 和 hm-main</p>
<pre><code class="language-js">app.component('hm-button', HmButton)
</code></pre>
<p>使用时 <code>&lt;hm-button&gt; &lt;/hm-button&gt;</code></p>
</li>
<li>
<p>注册使用大驼峰命名法，例如 HmHeader 和 HmMain</p>
<pre><code class="language-jsx">app.component('HmButton', HmButton)
</code></pre>
<p>使用时 <code>&lt;HmButton&gt; &lt;/HmButton&gt;</code> 和 <code>&lt;hm-button&gt; &lt;/hm-button&gt;</code>  都可以</p>
</li>
</ul>
<p>推荐定义组件名时, 用大驼峰命名法, 更加方便</p>
<p>全局注册</p>
<pre><code class="language-jsx">app.component('HmButton', HmButton)
</code></pre>
<p>局部注册:</p>
<pre><code class="language-jsx">components: {
  HmHeader,
  HmMain,
  HmFooter
}
</code></pre>
<p>使用时, 推荐遵循html5规范, 小写横杠隔开</p>
<pre><code class="language-jsx">&lt;hm-header&gt;&lt;/hm-header&gt;
&lt;hm-main&gt;&lt;/hm-main&gt;
&lt;hm-footer&gt;&lt;/hm-footer&gt;
</code></pre>
<h3 id="通过-name-注册组件-了解">通过 name 注册组件 (了解)</h3>
<p>在注册组件期间，除了可以直接提供组件的注册名称之外，还可以把组件的 name 属性作为注册后组件的名称</p>
<p>组件内容:</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;button&gt;按钮组件&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'HmButton'
}
&lt;/script&gt;

&lt;style lang=&quot;less&quot;&gt;
button {
  width: 80px;
  height: 50px;
  border-radius: 5px;
  background-color: pink;
}
&lt;/style&gt;
</code></pre>
<p>进行注册:</p>
<pre><code class="language-jsx">import HmButton from './components/hm-button.vue'
app.component(HmButton.name, HmButton)  // 等价于 app.component('HmButton', HmButton)
</code></pre>
<h2 id="组件的样式冲突-scoped">组件的样式冲突  <code>scoped</code></h2>
<p>默认情况下，写在组件中的样式会<code>全局生效</code>，因此很容易造成多个组件之间的样式冲突问题。</p>
<p>根本原因是：单页应用程序中，所有组件的结构，都是基于唯一的 index.html 页面进行呈现的,</p>
<p>组件样式默认会作用到全局, 就会影响到整个 index.html 中的 dom 元素</p>
<ul>
<li>
<p><code>全局样式</code>: 默认组件中的样式会作用到全局</p>
</li>
<li>
<p><code>局部样式</code>: 可以给组件加上 scoped 属性, 可以让样式只作用于当前组件</p>
</li>
</ul>
<pre><code class="language-jsx">&lt;style lang=&quot;less&quot; scoped&gt;
div {
  background-color: pink;
}
&lt;/style&gt;
</code></pre>
<p>原理:</p>
<ol>
<li>
<p>添加scoped后, 会给当前组件中所有元素, 添加上一个自定义属性</p>
<figure data-type="image" tabindex="9"><img src="https://lucas-y.github.io//post-images/1610547190490.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>添加scoped后,  每个style样式, 也会加上对应的属性选择器</p>
<figure data-type="image" tabindex="10"><img src="https://lucas-y.github.io//post-images/1610547214600.png" alt="" loading="lazy"></figure>
</li>
</ol>
<p>最终效果: 必须是当前组件的元素, 才会有这个自定义属性, 才会被这个样式作用到</p>
<h1 id="组件通信入门">组件通信入门</h1>
<p>每个组件都有自己的数据, 提供在data中, 每个组件的数据是独立的, 组件数据无法互相直接访问 (合理的)</p>
<p>但是如果需要跨组件访问数据, 就需要用到组件通信</p>
<p>组件通信的方式有很多: 现在先关注两种,  父传子  子传父</p>
<h2 id="组件通信-父传子-props-传值">组件通信 - 父传子 props 传值</h2>
<p>语法:</p>
<ol>
<li>父组件通过给子组件加属性传值</li>
</ol>
<pre><code class="language-jsx">&lt;jack price=&quot;100&quot; title=&quot;不错&quot; :info=&quot;msg&quot;&gt;&lt;/jack&gt;
</code></pre>
<ol start="2">
<li>子组件中, 通过props属性接收</li>
</ol>
<pre><code class="language-js">props: ['price', 'title', 'info']
</code></pre>
<p><strong>需求: 封装一个商品组件 my-product</strong></p>
<figure data-type="image" tabindex="11"><img src="https://lucas-y.github.io//post-images/1610547246213.png" alt="" loading="lazy"></figure>
<p><code>my-product.vue</code></p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;my-product&quot;&gt;
    &lt;h3&gt;标题: {{ title }}&lt;/h3&gt;
    &lt;p&gt;价格: {{ price }}元&lt;/p&gt;
    &lt;p&gt;{{ info }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: ['title', 'price', 'info']
}
&lt;/script&gt;

&lt;style&gt;
.my-product {
  width: 400px;
  padding: 20px;
  border: 2px solid #000;
  border-radius: 5px;
  margin: 10px;
}
&lt;/style&gt;
</code></pre>
<p><code>app.vue</code></p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;h3&gt;我是app组件的内容&lt;/h3&gt;
    &lt;my-product price=&quot;100&quot; title=&quot;超级好吃的口水鸡&quot; :info=&quot;msg&quot;&gt;&lt;/my-product&gt;
    &lt;my-product price=&quot;80&quot; title=&quot;超级难闻的榴莲&quot; :info=&quot;msg&quot;&gt;&lt;/my-product&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import MyProduct from './components/my-product.vue'
export default {
  data () {
    return {
      msg: '开业大酬宾, 全场八折'
    }
  },
  components: {
    MyProduct
  }
}
&lt;/script&gt;
</code></pre>
<h2 id="v-for-遍历展示组件练习">v-for 遍历展示组件练习</h2>
<p><strong>需求: 遍历展示商品列表</strong></p>
<p>假定, 发送请求回来的商品数据,</p>
<pre><code class="language-jsx">list: [
  { id: 1, proname: '超级好吃的棒棒糖', proprice: 18.8 },
  { id: 2, proname: '超级好吃的大鸡腿', proprice: 34.2 },
  { id: 3, proname: '超级无敌的冰激凌', proprice: 14.2 }
]
</code></pre>
<p>v-for 遍历展示</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;h3&gt;我是app组件的内容&lt;/h3&gt;
    &lt;my-product 
      v-for=&quot;item in list&quot; :key=&quot;item.id&quot; 
      :price=&quot;item.proprice&quot; 
      :title=&quot;item.proname&quot; 
      :info=&quot;msg&quot;&gt;
    &lt;/my-product&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://lucas-y.github.io//post-images/1610547282834.png" alt="" loading="lazy"></figure>
<h2 id="区分-props-和-data">区分 props 和 data</h2>
<p>组件中的数据来源, data  props</p>
<p><strong>data 中的数据允许修改, props 中的数据不允许修改</strong>   遵循开发规范: 单向数据流</p>
<h2 id="组件通信-子传父">组件通信 - 子传父</h2>
<p><strong>需求: 砍价</strong></p>
<figure data-type="image" tabindex="13"><img src="https://lucas-y.github.io//post-images/1610547328168.png" alt="" loading="lazy"></figure>
<ol>
<li>
<p>子组件可以通过 this.$emit('事件名', 参数1, 参数2, ...) 触发事件的同时传参的</p>
<pre><code class="language-jsx">this.$emit('say-price', 2)
</code></pre>
</li>
<li>
<p>父组件给子组件注册一个自定义事件</p>
<pre><code class="language-jsx">&lt;my-product 
  ...
  @say-price=&quot;sayPrice&quot;&gt;
&lt;/my-product&gt;
</code></pre>
<p>父组件并提供对应的函数接收参数</p>
<pre><code class="language-jsx">methods: {
  sayPrice (num) {
    console.log(num)
  }
},
</code></pre>
</li>
</ol>
<hr>
<p>问题: 改价需要知道, 是改的哪个id商品的价格 ? 子组件自己都不知道自己的 id ?</p>
<p>思路:</p>
<ol>
<li>
<p>先父传子, 将 id 传递给子组件</p>
<pre><code class="language-jsx">&lt;my-product 
  v-for=&quot;item in list&quot; 
  :key=&quot;item.id&quot;
  :price=&quot;item.proprice&quot;
  :title=&quot;item.proname&quot;
  
  :id=&quot;item.id&quot;
  
  :info=&quot;msg&quot;
  @say-price=&quot;sayPrice&quot;&gt;
&lt;/my-product&gt;
</code></pre>
</li>
<li>
<p>子组件 props 接收 id</p>
<pre><code class="language-jsx">props: ['title', 'price', 'info', 'id'],
</code></pre>
</li>
<li>
<p>子传父时带上 id</p>
<pre><code class="language-jsx">this.$emit('say-price', this.id, 2)
</code></pre>
</li>
<li>
<p>父组件接收参数, 此时有两个参数了 id 和 num, 编写砍价逻辑</p>
<pre><code class="language-jsx">sayPrice (id, num) {
  // console.log(id, num)
  const item = this.list.find(item =&gt; item.id === id)
  let result = item.proprice - num
  if (result &lt;= item.lowprice) {
    result = item.lowprice
    alert('老哥最低价了:' + result + '元')
  }
  item.proprice = result.toFixed(2)
}
</code></pre>
</li>
</ol>
<h2 id="props-校验-了解">props 校验 (了解)</h2>
<p><strong>props 是父传子, 传递给子组件的数据, 为了提高 子组件被使用时 的稳定性, 可以进行props校验</strong>, 验证传递的数据是否符合要求</p>
<p>默认的数组形式, 不会进行校验, 如果希望校验, 需要提供对象形式的 props</p>
<pre><code class="language-jsx">props: {
	...
}
</code></pre>
<p>props 提供了多种数据验证方案，例如：</p>
<ul>
<li>基础的类型检查  Number</li>
<li>多个可能的类型 [String, Number]</li>
<li>必填项校验   required: true</li>
<li>默认值 default: 100</li>
<li>自定义验证函数</li>
</ul>
<p>官网语法: <a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81">地址</a></p>
<pre><code class="language-js">{
  props: {
    // 基础的类型检查
    propA: Number,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: {
      type: String,
      required: true
    },
    // 带有默认值的数字
    propD: {
      type: Number,
      default: 100
    },
    // -------------------------------------------------------------------------
    // 自定义验证函数
    propF: {
      validator: function (value) {
        // 这个值必须匹配下列字符串中的一个
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    }
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js高级]]></title>
        <id>https://lucas-y.github.io/post/js-gao-ji/</id>
        <link href="https://lucas-y.github.io/post/js-gao-ji/">
        </link>
        <updated>2021-01-12T03:41:52.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="暂时性死区">暂时性死区</h2>
<p><a href="https://es6.ruanyifeng.com/#docs/let">暂时性死区</a></p>
<h2 id="继承">继承</h2>
<p><a href="https://www.cnblogs.com/sarahwang/p/6879161.html">jicheng</a></p>
<ul>
<li>原型链继承（给原型对象添加的成员，实例对象可以继承到）</li>
</ul>
<ol>
<li>直接给原型对象添加 Person.prototype.xx = yyy;<br>
缺点：添加过多成员，以上写法重复，麻烦</li>
</ol>
<pre><code class="language-js">function Person() {}
Person.prototype.color = &quot;lime&quot;;
Person.prototype.sayHi = function () {
    console.log(&quot;hi&quot;);
}

var p = new Person();
console.log(p.color); // lime
p.sayHi();
</code></pre>
<ol start="2">
<li>原型替换  Person.prototype = {//...}<br>
缺点：造成了constructor属性丢失了<br>
解决：手动给新的原型对象补上</li>
</ol>
<pre><code class="language-js">function Person() {}
Person.prototype = {
    constructor: Person,
    sayHi: function () {
        console.log(&quot;hi&quot;);
    },
    show: function () {
        console.log(&quot;show is ok&quot;);
    },
    // ...
};
var p = new Person();
p.sayHi();
p.show();
</code></pre>
<ol start="3">
<li>Student.prototype = new Person();</li>
</ol>
<pre><code class="language-js">    function Person () {
      this.head = '脑袋瓜子';
      this.emotion = ['喜', '怒', '哀', '乐']; //人都有喜怒哀乐
    }
    function Student(studentID) {
      this.studentID = studentID;
    }
    Student.prototype = new Person();

    var stu1 = new Student(1001);
    console.log(stu1.emotion); //['喜', '怒', '哀', '乐']

    stu1.emotion.push('愁');
    console.log(stu1.emotion); //[&quot;喜&quot;, &quot;怒&quot;, &quot;哀&quot;, &quot;乐&quot;, &quot;愁&quot;]
    
    var stu2 = new Student(1002);
    console.log(stu2.emotion); //[&quot;喜&quot;, &quot;怒&quot;, &quot;哀&quot;, &quot;乐&quot;, &quot;愁&quot;]
</code></pre>
<p><strong>原型上任何类型的属性值都不会通过实例被重写，但是引用类型的属性值会受到实例的影响而修改</strong></p>
<ul>
<li>
<p>借用构造函数继承</p>
<pre><code class="language-js">  function Person () {
    this.head = '脑袋瓜子';
    this.emotion = ['喜', '怒', '哀', '乐']; //人都有喜怒哀乐
  }
  function Student(studentID) {
    this.studentID = studentID;
    Person.call(this);
  }

  var stu1 = new Student(1001);
  console.log(stu1.emotion); //['喜', '怒', '哀', '乐']

  stu1.emotion.push('愁');
  console.log(stu1.emotion); //[&quot;喜&quot;, &quot;怒&quot;, &quot;哀&quot;, &quot;乐&quot;, &quot;愁&quot;]
  
  var stu2 = new Student(1002);
  console.log(stu2.emotion); //[&quot;喜&quot;, &quot;怒&quot;, &quot;哀&quot;, &quot;乐&quot;]
</code></pre>
<p><strong>每个实例都拷贝一份，占用内存大，尤其是方法过多的时候</strong></p>
</li>
<li>
<p>组合继承<br>
<code>既可以保证每个实例都有它自己的属性，又能做到对一些属性和方法的复用</code></p>
</li>
</ul>
<pre><code class="language-js">    function Person () {
      this.head = '脑袋瓜子';
      this.emotion = ['喜', '怒', '哀', '乐']; //人都有喜怒哀乐
    }
    Person.prototype.eat = function () {
      console.log('吃吃喝喝');
    }
    Person.prototype.sleep = function () {
      console.log('睡觉');
    }
    Person.prototype.run = function () {
      console.log('快跑');
    }
    function Student(studentID) {
      this.studentID = studentID;
      Person.call(this);
    }
    
    Student.prototype = new Person();  
    Student.prototype.constructor = Student;  

    var stu1 = new Student(1001);
    console.log(stu1.emotion); //['喜', '怒', '哀', '乐']

    stu1.emotion.push('愁');
    console.log(stu1.emotion); //[&quot;喜&quot;, &quot;怒&quot;, &quot;哀&quot;, &quot;乐&quot;, &quot;愁&quot;]
    
    var stu2 = new Student(1002);
    console.log(stu2.emotion); //[&quot;喜&quot;, &quot;怒&quot;, &quot;哀&quot;, &quot;乐&quot;]

    stu1.eat(); //吃吃喝喝
    stu2.run(); //快跑
    console.log(stu1.constructor);  //Student
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react]]></title>
        <id>https://lucas-y.github.io/post/react/</id>
        <link href="https://lucas-y.github.io/post/react/">
        </link>
        <updated>2020-12-28T00:33:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="react-是什么">react 是什么</h2>
<ul>
<li>React是一个JS库，用来构建用户界面（写HTML，构建web应用）</li>
<li>从 MVC 的角度来看，相当于 视图层 V（View） 的内容。</li>
</ul>
<h2 id="react-的特点">react 的特点</h2>
<ul>
<li>1 声明式： 我们只需要描述页面长什么样子就可以了，React负责更新页面</li>
<li>2 基于组件（组件化）</li>
<li>3 学习一次，随处使用（Web 、 安卓/ios、vr ...）</li>
</ul>
<h2 id="react-的基本使用">React 的基本使用</h2>
<ul>
<li>1 安装：npm i react react-dom</li>
<li>2 引入 react 和 react-dom 两个js文件（注意：引入顺序，react在前，react-dom 在后）</li>
<li>3 创建 React 元素
<ul>
<li><code>const h1 = React.createElement('h1', null, '子节点')</code></li>
</ul>
</li>
<li>4 渲染创建好的 React 元素，到页面中
<ul>
<li><code>ReactDOM.render(h1, document.getElementById('root'))</code></li>
</ul>
</li>
</ul>
<h2 id="reactcreateelement-方法的说明">React.createElement() 方法的说明</h2>
<ul>
<li>作用：创建react元素的</li>
</ul>
<pre><code class="language-js">// 创建React元素
// 第一个参数：表示要创建什么元素，就是 HTML 标签名称
// 第二个参数：表示元素自身属性，如果没有就传 null
//  如果要指定元素自身的属性，就传递一个对象（{}）
//  1 class ==&gt; className
//  2 for ==&gt; htmlFor
// 第三个及其以后的参数：表示元素的子节点（文本、元素节点）
//  如果是文本节点，就直接传递 字符串。
//  如果是元素节点，就继续调用 React.createElement() 方法，创建新的React元素节点
//
// const h1 = React.createElement('div', null, 'Hello React')
const h1 = React.createElement(
  'h1',
  {
    id: 'title',
    className: 'cls',
    htmlFor: 'd'
  },
  'Hello React',
  'test 文本节点',
  React.createElement('span', null, '这是一个span')
)
</code></pre>
<h2 id="react-脚手架初始化项目的步骤">React 脚手架初始化项目的步骤</h2>
<ul>
<li>命令：<code>npx create-react-app 项目名称</code>
<ul>
<li>比如：<code>npx create-react-app my-app</code></li>
</ul>
</li>
<li>npx 命令：简化使用脚手架初始化项目的流程
<ul>
<li>不使用npx：1 先全局安装脚手架的包 2 使用脚手架包提供的命令来初始化项目</li>
<li>使用 npx：不需要再全局安装脚手架的包，直接就可以初始化项目</li>
</ul>
</li>
<li>如何启动项目？进入项目根目录然后，执行以下命令
<ul>
<li>yarn start</li>
<li>npm start</li>
</ul>
</li>
</ul>
<h2 id="在脚手架中使用react">在脚手架中使用react</h2>
<ul>
<li>1 导入
<ul>
<li><code>import React from 'react'</code></li>
<li><code>import ReactDOM from 'react-dom'</code></li>
</ul>
</li>
</ul>
<h2 id="jsx">JSX</h2>
<ul>
<li>
<p>为什么要学习 JSX ？</p>
<ul>
<li>因为 createElement 形式，太繁琐，不直观，书写效率不高，所以，我们不想用这种方式。</li>
<li>JSX 特点：不反锁，直观，书写效率高</li>
</ul>
</li>
<li>
<p>JSX 是什么？ JavaScript XML（HTML），也就是在 JS 中书写 HTMl 格式的代码</p>
</li>
</ul>
<h2 id="jsx-的基本使用">JSX 的基本使用</h2>
<ul>
<li>1 导入 react 和 react-dom</li>
<li>2 使用 JSX 语法创建 React 元素
<ul>
<li>JSX 就跟写 HTML 一样</li>
</ul>
</li>
<li>3 渲染创建好的 React 元素</li>
</ul>
<h2 id="jsx-语法的注意点">JSX 语法的注意点</h2>
<ul>
<li>1 JSX元素的属性名推荐使用：驼峰命名法</li>
<li>2 class ===&gt; className</li>
<li>3 如果元素没有子节点，可以使用 单标签 方式来结束
<ul>
<li>比如：<code>&lt;div /&gt;</code></li>
</ul>
</li>
<li>4 推荐使用 () 来包裹JSX，从而避免JS中自动插入分号机制</li>
</ul>
<h2 id="在-jsx-中使用-js-表达式数据">在 JSX 中使用 JS 表达式（数据）</h2>
<ul>
<li>语法：使用 {} ，就可以在 JSX 中使用 JS 中的数据了
<ul>
<li><code>&lt;div&gt;Hello {name + '666'}&lt;/div&gt;</code></li>
</ul>
</li>
<li>原则：可以在 {} 中使用任何的 JS 表达式。</li>
<li>注意：不能在 {} 中，使用 语句！
<ul>
<li>比如： if/for/switch ...</li>
</ul>
</li>
<li>注意：不能在 {} 中使用对象，除了 style 属性以外！！！</li>
<li>JSX 自身也是一个JS表达式，所以，可以在 {} 中继续使用 JSX ！！！</li>
</ul>
<h2 id="react-的条件渲染">React 的条件渲染</h2>
<ul>
<li>1 使用if/esle来实现</li>
</ul>
<pre><code class="language-js">const loadData = () =&gt; {
  if (isLoading) {
    return &lt;div&gt;loading...&lt;/div&gt;
  }

  return &lt;div&gt;加载完成后的列表结构&lt;/div&gt;
}

const h1 = &lt;div&gt;{loadData()}&lt;/div&gt;
</code></pre>
<ul>
<li>2 使用三元表达式</li>
</ul>
<pre><code class="language-js">const loadData = () =&gt; {
  return isLoading ? &lt;div&gt;loading...&lt;/div&gt; : &lt;div&gt;加载完成后的列表结构&lt;/div&gt;
}
</code></pre>
<ul>
<li>3 逻辑运算符 &amp;&amp;</li>
</ul>
<pre><code class="language-js">const loadData = () =&gt; {
  return isLoading &amp;&amp; &lt;div&gt;loading...&lt;/div&gt;
}
</code></pre>
<h2 id="react-中的列表渲染">React 中的列表渲染</h2>
<ul>
<li>使用数组的 map 方法来进行列表渲染</li>
<li>需要给被遍历生成的元素添加 key 属性，key 应该是唯一的。尽量避免使用 index 作为索引号。</li>
<li>剩下的就是 JS 中 map 方法的使用了。</li>
</ul>
<pre><code class="language-js">&lt;ul&gt;
  {songs.map(item =&gt; (
    &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;
  ))}
&lt;/ul&gt;
</code></pre>
<h2 id="react-中给-jsx-添加样式">React 中给 JSX 添加样式</h2>
<ul>
<li>1 行内样式（style） 不推荐</li>
</ul>
<pre><code class="language-js">const h1 = (
  &lt;h1 style={{ color: 'red', fontSize: 30, backgroundColor: 'hotpink' }}&gt;
    我变大了
  &lt;/h1&gt;
)
</code></pre>
<ul>
<li>2 className 类名 --- 推荐！！！</li>
</ul>
<pre><code class="language-js">const h1 = &lt;h1 className=&quot;pink&quot;&gt;我变大了&lt;/h1&gt;
</code></pre>
<h2 id="案例">案例</h2>
<pre><code class="language-js">[
  { user: '张三', content: '哈哈，沙发' },
  { user: '张三2', content: '哈哈，板凳' },
  { user: '张三3', content: '哈哈，凉席' },
  { user: '张三4', content: '哈哈，砖头' },
  { user: '张三5', content: '哈哈，楼下山炮' }
]
</code></pre>
<h2 id="函数组件">函数组件</h2>
<ul>
<li>就是使用 JS 中的函数创建的组件，叫做函数组件。</li>
</ul>
<pre><code class="language-js">const Hello = () =&gt; &lt;div&gt;这是通过箭头函数创建的组件&lt;/div&gt;
</code></pre>
<ul>
<li>
<p>约定1：必须有返回值</p>
<ul>
<li>返回值可以为null，表示不渲染任何内容</li>
<li>如果想要渲染内容，一般就是返回 JSX</li>
</ul>
</li>
<li>
<p>约定2：组件名称必须以大写字母开头</p>
<ul>
<li>用来区分普通的 react元素 和 react组件</li>
</ul>
</li>
<li>
<p>约定3：使用函数名称作为组件的标签名称来渲染</p>
<ul>
<li><code>ReactDOM.render(&lt;Hello /&gt;, root)</code></li>
</ul>
</li>
</ul>
<h2 id="es6中的class">ES6中的class</h2>
<ul>
<li>语法：</li>
</ul>
<pre><code class="language-js">class Person {
  // 添加属性：
  constructor(age) {
    this.name = 'jack'

    this.age = age
  }

  // 添加实例方法
  say() {}
}

const p = new Person(30)
</code></pre>
<ul>
<li>继承：</li>
</ul>
<pre><code class="language-js">// 父类
class Person {
  constructor() {
    this.name = 'zhangsan'
  }
}

// 子类
class Chinese extends Person {
  constructor() {
    // 注意：手动调用super()
    // super 即 父类中的构造函数（constructor）
    super()

    // this. ....
  }
}

// 创建子类的实例对象，此时，c 就可以直接使用父类中的属性或方法了
const c = new Chinese()
// c =&gt; { name: 'zhangsan' }
</code></pre>
<h2 id="类组件">类组件</h2>
<ul>
<li>类组件：通过 ES6 中的class创建的组件，叫做 类组件</li>
<li>函数组件中的约定都适用于类组件</li>
<li>约定：类组件必须得继承自 React.Component 父类</li>
<li>约定：类组件中必须提供一个 render 方法，通过 render 方法的返回值来指定要渲染的内容</li>
</ul>
<pre><code class="language-js">// 类组件
class Hello extends React.Component {
  // render 方法是 React 中固定的一个方法名称
  render() {
    // return null
    return &lt;h1&gt;这是我的第一个 class 组件&lt;/h1&gt;
  }
}
</code></pre>
<h2 id="将组件抽离到独立的js文件中">将组件抽离到独立的JS文件中</h2>
<pre><code class="language-js">// 注意：不管是函数组件还是类组件，或者使用 JSX ，都需要导入 React！！！
import React from 'react'

// 创建 class 组件
// class Hello1 extends React.Component {
//   render() {
//     return &lt;div&gt;这是一个独立的组件&lt;/div&gt;
//   }
// }

// JSX -&gt; React.createElement()
const Hello1 = () =&gt; &lt;div&gt;这是一个独立的组件&lt;/div&gt;

// 导出组件
export default Hello1
</code></pre>
<h2 id="绑定事件">绑定事件</h2>
<ul>
<li>1 给 JSX 添加 onClick</li>
<li>2 在 {} 中，指定事件处理程序的名称（也就是一个函数名称）
<ul>
<li>注意：千万不要调用</li>
</ul>
</li>
</ul>
<pre><code class="language-js">const handleClick = () =&gt; {}

&lt;button onClick={handleClick}&gt;&lt;/button&gt;
</code></pre>
<pre><code class="language-js">// 在类组件中绑定事件
class Hello extends React.Component {
  // 事件处理程序
  handleClick() {
    console.log('你点我！')
  }

  render() {
    return &lt;button onClick={this.handleClick}&gt;点我 - class&lt;/button&gt;
  }
}
</code></pre>
<h2 id="事件对象">事件对象</h2>
<ul>
<li>如何获取到事件对象？通过事件处理程序的参数 e 来获取到</li>
<li>React 中的事件对象是一个 合成事件。</li>
<li>使用方式，与原生DOM中的使用方式相同。</li>
</ul>
<h2 id="有状态组件和无状态组件">有状态组件和无状态组件</h2>
<ul>
<li>有状态组件：class（类）组件
<ul>
<li>职责（什么时候使用）：负责更新UI（页面），也就是如果页面中的内容，需要变化</li>
<li>动</li>
</ul>
</li>
<li>无状态组件：函数组件
<ul>
<li>职责：负责展示内容</li>
<li>静</li>
</ul>
</li>
</ul>
<h2 id="class组件中的状态">class组件中的状态</h2>
<ul>
<li>状态（state）即数据</li>
<li>如何初始化状态？</li>
</ul>
<pre><code class="language-js">class Hello extends React.Component {
  constructor() {
    super()

    // 状态初始化
    this.state = {
      count: 0
    }
  }

  // 简化语法：
  // state = {
  //   count: 66
  // }

  // 在 JSX 中使用状态
  render() {
    return &lt;div&gt;计数器：{ this.state.count }&lt;/div&gt;
  }
}
</code></pre>
<h2 id="setstate">setState</h2>
<ul>
<li>作用：1 修改state 2 更新UI（页面）</li>
<li>语法：</li>
</ul>
<pre><code class="language-js">this.setState({
  count: this.state.count + 1
})
</code></pre>
<ul>
<li>注意：不要直接修改 state ！！！
<ul>
<li>错误演示：<code>this.state.count += 1</code>！！！</li>
</ul>
</li>
</ul>
<h2 id="事件处理程序中this指向问题">事件处理程序中this指向问题</h2>
<ul>
<li>1 箭头函数：</li>
</ul>
<pre><code class="language-js">// 事件处理程序中，我们要的 this 是当前组件的实例对象（它是React在渲染组件时创建）
class Hello extends React.Component {
  // 简化语法：
  state = {
    count: 0
  }

  handleClick() {
    this.setState({ ... })
  }

  render() {
    console.log('render：', this)
    return (
      &lt;div&gt;
        计数器：{this.state.count}{' '}
        &lt;button onClick={() =&gt; this.handleClick()}&gt;+1&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<ul>
<li>2 使用 bind 方法解决：</li>
</ul>
<pre><code class="language-js">constructor() {
  this.handleClick = this.handleClick.bind(this)
}

render() {
  // 此处的 handleClick 就是绑定 this 后的事件处理程序了
  return (
    &lt;button onClick={this.handleClick}&gt;&lt;/button&gt;
  )
}
</code></pre>
<ul>
<li>3 利用 class 实例方法的箭头函数形式：（推荐）</li>
</ul>
<pre><code class="language-js">class Hello extends React.Component {
  handleClick = () =&gt; {
    this.setState({ ... })
  }

  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;&lt;/button&gt;
    )
  }
}
</code></pre>
<h2 id="受控组件">受控组件</h2>
<ul>
<li>受控组件：其值收到 react 控制的表单元素，叫做受控组件</li>
</ul>
<pre><code class="language-js">state = {
  txt: ''
}

changeTxt = e =&gt; {
  this.setState({
    txt: e.target.value
  })
}

render () {
  return &lt;input type=&quot;text&quot; value={this.state.txt} onChange={this.changeTxt} /&gt;
}
</code></pre>
<h2 id="非受控组件">非受控组件</h2>
<ul>
<li>借助于 ref 就可以通过 非受控组件 的方式，来获取到的表单元素的值。</li>
<li>ref 的作用：获取DOM对象或组件。</li>
</ul>
<pre><code class="language-js">this.ref = React.createRef()

&lt;input ref={this.ref} /&gt;

文本框的值：
this.ref.current.value
</code></pre>
<h2 id="props的使用">props的使用</h2>
<ul>
<li>作用：接收到传递给组件中的属性</li>
<li>在函数组件中如何获取到 props？ 通过函数的参数</li>
<li>在 类组件 中如何获取到 props？ 通过 this.props 来获取</li>
<li>props 是一个对象！！！</li>
<li>特点：只读！！！（ 只能读取 props 对象中的属性，而不能修改 props 对象中的属性 ）</li>
<li>可以给组件传递任何类型的数据。</li>
<li>注意：如果在 class 组件中，手动添加了 constructor ，那么，就应该通过参数获取到 props， 然后传递给 super，这样，才能够在 constructor 中，获取到 props！！！</li>
</ul>
<pre><code class="language-js">const Hello = props =&gt; {
  // props 就表示传递给组件的属性
}

&lt;Hello name=&quot;jack&quot; age={19} colors={['red']} /&gt;


// 类组件：
class Hello extends React.Component {
  constructor(props) {
    super(props)

    // console.log('在构造函数中，获取到 props ', this.props)
    console.log('在构造函数中，获取到 props ', props)
  }

  render() {
    console.log('class组件中获取到props：', this.props)
    return (
      &lt;div&gt;
        &lt;h1&gt;props：{this.props.age}&lt;/h1&gt;
        {this.props.colors.map((item, index) =&gt; (
          &lt;p key={index}&gt;{item}&lt;/p&gt;
        ))}
      &lt;/div&gt;
    )
  }
}
</code></pre>
<h2 id="组件通讯">组件通讯</h2>
<h3 id="父到子">父到子</h3>
<ul>
<li>1 父组件中提供状态</li>
<li>2 在子组件标签上添加属性，值为 父组件中的状态</li>
<li>3 子组件中通过 props 来接收父组件中传递过来的数据</li>
</ul>
<pre><code class="language-js">
// 父组件：
class Parent extends React.Component {
  // 提供数据
  state = {
    lastName: '王'
  }

  render() {
    return (
      &lt;div className=&quot;parent&quot;&gt;
        &lt;h1&gt;父组件：&lt;/h1&gt;
        {/* 1 通过属性给子组件传递数据 */}
        &lt;Child name={this.state.lastName} /&gt;
      &lt;/div&gt;
    )
  }
}

// 子组件：
// 2 子组件中通过 props 接收数据
const Child = props =&gt; {
  return &lt;p className=&quot;child&quot;&gt;这是子组件：{props.name}&lt;/p&gt;
}
</code></pre>
<h3 id="子到父">子到父</h3>
<ul>
<li>
<p>思路：父组件提供一个事件（函数），让子组件调用；子组件调用的时候，将数据作为参数的传递，父组件中通过事件（函数）的参数，就拿到子组件中的数据了。</p>
</li>
<li>
<p>1 父组件提供事件</p>
</li>
<li>
<p>2 将事件通过props传递给子组件</p>
</li>
<li>
<p>3 子组件中通过props接收到父组件中传递过来的事件</p>
</li>
<li>
<p>4 子组件调用该事件，将数据作为参数传递</p>
</li>
<li>
<p>注意点：父组件提供的方法中 this 执行问题。</p>
<ul>
<li>为什么会有这个问题？因为这个方法不是父组件自己调用的，是由其他组件调用的，所以，需要处理this指向。</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 1 提供事件（回调函数，）
//  事件是子组件调用的，因此，先要通过 props 传递给子组件
// 2 将事件传递给子组件
class Parent extends React.Component {
  state = {
    msg: ''
  }

  getChildMsg = data =&gt; {
    console.log('父组件中的方法调用了', data)
    this.setState({
      msg: data
    })
  }

  // 注意：this指向问题，因为这个方法是由子组件调用的，所以，应该提前处理好 this 指向！
  /* getChildMsg(data) {
    console.log('父组件中的方法调用了', data, this)
    this.setState({
      msg: data
    })
  } */

  render() {
    return (
      &lt;div className=&quot;parent&quot;&gt;
        &lt;h1&gt;父组件：{this.state.msg}&lt;/h1&gt;
        &lt;Child fn={this.getChildMsg} /&gt;
      &lt;/div&gt;
    )
  }
}

// 子组件：
// 3 子组件中通过 props 接收到父组件中传递过来的事件
// 4 子组件中调用传递过来的事件， 将数据作为事件的参数传递
const Child = props =&gt; {
  // console.log(props)
  const handleClick = () =&gt; {
    // 调用
    props.fn('撩汉子')
  }

  return (
    &lt;p className=&quot;child&quot;&gt;
      这是子组件：
      &lt;button onClick={handleClick}&gt;发送数据给父组件&lt;/button&gt;
    &lt;/p&gt;
  )
}
</code></pre>
<h3 id="兄弟组件">兄弟组件</h3>
<ul>
<li>思路：<strong>状态提升</strong>，也就是：将两个兄弟组件之间的共享数据，放在父组件中。</li>
<li>父组件的职责：1 提供共享数据（state） 2 提供修改状态的方法</li>
<li>例子：如果 子组件2 要传递数据给 子组件1</li>
<li>子组件1：只要通过 props 接收到父组件中传递过来的数据（父 -&gt; 子）</li>
<li>子组件2：调用父组件中修改状态的方法（子 -&gt; 父）
<ul>
<li>但是，需要先通过 props 获取到父组件中传递过来的方法</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 父组件
// 1 提供状态
// 2 提供操作状态的方法
class Parent extends React.Component {
  state = {
    msg: '默认值'
  }

  updateMsg = data =&gt; {
    this.setState({
      msg: data
    })
  }

  render() {
    return (
      &lt;div className=&quot;parent&quot;&gt;
        这是父组件：
        &lt;Child1 msg={this.state.msg} /&gt;
        &lt;Child2 updateMsg={this.updateMsg} /&gt;
      &lt;/div&gt;
    )
  }
}

// 子组件1
// 3 接收数据（数据由父组件提供）
class Child1 extends React.Component {
  render() {
    return &lt;div className=&quot;child&quot;&gt;这是子组件1：{this.props.msg}&lt;/div&gt;
  }
}

// 子组件2：
// 4 在父组件中传递事件给子组件
// 5 给按钮绑定单击事件
// 6 调用父组件中的事件来更新数据
class Child2 extends React.Component {
  // 单击事件
  handleClick = () =&gt; {
    // 调用父组件的事件
    this.props.updateMsg('子组件2222222222222222222222')
  }

  render() {
    return (
      &lt;div className=&quot;child2&quot;&gt;
        这是子组件2：
        &lt;button onClick={this.handleClick}&gt;传递数据给 Child1&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<h2 id="评论列表案例">评论列表案例</h2>
<ul>
<li>
<p>分析：因为 CommentList 和 CommentForm 这两个子组件中，都要用到 评论列表 数据，所以，就利用 状态提升 的思想，将评论列表数据放在了 父组件Comment 中。</p>
<ul>
<li>父组件的两个职责：1 提供评论列表数据状态（list） 2 提供修改状态的方法（updateComment）</li>
</ul>
</li>
<li>
<p>功能1：渲染评论列表</p>
<ul>
<li>利用 父-&gt;子 的通讯，将父组件中的 list 传递给 子组件；子组件中通过 props 接收</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 父组件中渲染子组件：
&lt;CommentList list={this.state.list} /&gt;

// 子组件中：
&lt;ul&gt;
  {props.list.map(item =&gt; (
    &lt;li key={item.id}&gt;
      &lt;h3&gt;评论人：{item.name}&lt;/h3&gt;
      &lt;p&gt;评论内容：{item.content}&lt;/p&gt;
    &lt;/li&gt;
  ))}
&lt;/ul&gt;
</code></pre>
<ul>
<li>功能2：添加评论
<ul>
<li>a. 通过受控组件的方式，来获取到评论人和评论内容</li>
<li>b. 将用户输入的内容，添加到 list 中
<ul>
<li>因为 list 是由父组件提供的，所以，由父组件提供修改状态的方法（updateComment）；通过 props 传递给子组件后，由子组件调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 父组件中渲染子组件：
&lt;CommentForm updateComment={this.updateComment} /&gt;

// 子组件中：
// 发表评论
addComment = () =&gt; {
  const { name, content } = this.state
  // ...

  this.props.updateComment(name, content)

  // ...
}
</code></pre>
<h2 id="context">Context</h2>
<ul>
<li>使用场景：跨组件传递数据</li>
</ul>
<ol>
<li>如果两个组件是远方亲戚（比如，嵌套多层）可以使用Context实现组件通讯</li>
<li>Context提供了两个组件：Provider 和 Consumer</li>
<li>Provider组件：用来提供数据</li>
<li>Consumer组件：用来消费数据</li>
</ol>
<pre><code class="language-js">const { Provider, Consumer } = React.createContext()

&lt;Provider value={this.state.msg}&gt;
  &lt;div className=&quot;parent&quot;&gt;
    这是父组件：
    &lt;Child1 /&gt;
  &lt;/div&gt;
&lt;/Provider&gt;

// Child1 -&gt; Child2 -&gt; Child3

// Child3
// data 就是 Provider 中提供的 value
&lt;Consumer&gt;{data =&gt; &lt;p&gt;接收到的数据为：{data}&lt;/p&gt;}&lt;/Consumer&gt;
</code></pre>
<h2 id="组件的-children-属性">组件的 children 属性</h2>
<ul>
<li>作用：获取组件标签的子节点</li>
<li>获取方式： props.children</li>
<li>children 与普通的 props 属性相同，可以是任意值。</li>
</ul>
<pre><code class="language-js">&lt;Hello&gt;
  我是子节点 -&gt; 这就是 children 属性的内容。
&lt;/Hello&gt;
</code></pre>
<h2 id="props-校验">props 校验</h2>
<ul>
<li>
<p>场景：给组件添加 props 校验，来增强组件的健壮性。</p>
<ul>
<li>约定：封装公共组件的时候，都添加 props 校验</li>
</ul>
</li>
<li>
<p>1 安装：<code>yarn add prop-types</code></p>
</li>
<li>
<p>2 导入 <code>import PropTypes from 'prop-types'</code></p>
</li>
<li>
<p>3 给组件名称添加 <code>propTypes</code> 属性，值是一个对象</p>
</li>
<li>
<p>4 对象的键就是要校验的 props 名称，值是 <code>PropTypes.array</code> 等，从PropTypes中获取到的校验规则</p>
</li>
</ul>
<pre><code class="language-js">const Parent = () =&gt; { ... }

// 2 给组件添加 props 校验
Parent.propTypes = {
  // 规定 colors 属性的类型为：数组（array），如果将来使用组件的时候，传入的 colors 属性类型不是 array ，就会通过警告来告诉使用者。
  colors: PropTypes.array,

  gender: PropTypes.oneOf(['male', 'female']).isRequired
}
</code></pre>
<h2 id="props-默认值">props 默认值</h2>
<ul>
<li>可以通过 组件名.defaultProps = {} 来给组件添加 props 的默认值。</li>
</ul>
<pre><code class="language-js">const Parent = () =&gt; { ... }

// 添加 props 的默认值：
Parent.defaultProps = {
  gender: 'male'
}
</code></pre>
<h2 id="class组件生命周期">class组件生命周期</h2>
<ul>
<li>注意：只有 class 组件才会有生命周期</li>
<li><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">生命周期文档</a></li>
</ul>
<h3 id="1-挂载阶段">1 挂载阶段</h3>
<ul>
<li>1 constructor</li>
<li>2 render</li>
<li>3 <strong>componentDidMount</strong>
<ul>
<li>3.1 发送ajax请求</li>
<li>3.2 操作DOM</li>
</ul>
</li>
</ul>
<pre><code class="language-js">class Hello extends React.Component {
  // 最早执行：
  // 1 初始化state
  // 2 给事件处理程序绑定 this
  constructor(props) {
    super(props)

    console.warn('1 组件生命周期钩子函数： constructor')
  }

  // 作用1：可以用来在进入页面时（该组件渲染时），发送ajax请求
  // 作用2：可以操作DOM（因为 render 已经将 JSX 渲染到页面中了）
  componentDidMount() {
    console.warn(
      '3 组件生命周期钩子函数： componentDidMount',
      (document.getElementsByTagName('h1')[0].style.color = 'red')
    )
  }

  // 作用：渲染 UI，负责将 JSX 渲染到页面中
  // 注意：不要在 render 方法中调用 setState() 方法，否则，会造成死循环！
  render() {
    // this.setState({})
    console.warn('2 组件生命周期钩子函数： render')
    return (
      &lt;div&gt;
        &lt;h1&gt;class 组件&lt;/h1&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<h3 id="2-更新阶段">2 更新阶段</h3>
<ul>
<li>
<p>1 render（ 同挂载阶段的render ）</p>
</li>
<li>
<p>2 componentDidUpdate（ 知道 ）</p>
</li>
<li>
<p>导致组件更新的三种情况：</p>
<ul>
<li>1 setState()</li>
<li>2 组件接收到新的props</li>
<li>3 forceUpdate()</li>
</ul>
</li>
<li>
<p>注意：不管是 函数组件 还是 类组件，只要接收到新的 props ，那么，组件都会重新渲染</p>
</li>
</ul>
<pre><code class="language-js">class Hello extends React.Component {
  state = {
    count: 0
  }

  // 第一个参数：表示上一次的 props
  // 第二个参数：表示上一次的 state
  // 说明：可以在该钩子函数中调用 setState()，但是，一定要把 setState() 放在一个条件判断中
  //      比如：可以对比更新前后的 props 是否相同，或者 对比更新前后的 状态是否相同
  // 注意：不要直接调用 setState() 否则，会造成死循环
  componentDidUpdate(prevProps, prevState) {
    console.warn(
      '2 组件生命周期钩子函数： componentDidUpdate',
      document.getElementsByTagName('h1')[0].innerText,
      prevProps,
      prevState
    )

    // 如何获取最新的props 和 最新的state？
    console.log(this.props, this.state)
  }

  handleClick = () =&gt; {
    this.setState({
      count: this.state.count + 1
    })

    // 强制组件更新（知道即可）：
    // forceUpdate()
    // this.forceUpdate()
  }

  render() {
    console.warn('1 组件生命周期钩子函数： render')
    return (
      &lt;div&gt;
        &lt;Child count={this.state.count} /&gt;
        &lt;button onClick={this.handleClick}&gt;更新组件&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

// 当组件接收到新的 props 值时，也会触发组件更新
class Child extends React.Component {
  componentDidUpdate() {
    console.warn('子组件 -&gt; 的生命周期钩子函数： componentDidUpdate')
  }

  render() {
    console.warn('子组件 -&gt; 的生命周期钩子函数： render')
    return &lt;h1&gt;计数器：{this.props.count}&lt;/h1&gt;
  }
}
</code></pre>
<h3 id="3-卸载阶段">3 卸载阶段</h3>
<ul>
<li>触发时机：组件卸载，也就是从页面中消失的时候</li>
<li>componentWillUnmount
<ul>
<li>作用：执行清理工作，比如：清理定时器、给window绑定的事件等，我们手动开启的操作</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 当组件从页面中消失，此时，就会触发组件的卸载阶段
class Child extends React.Component {
  componentDidMount() {
    // 开启定时器
    // this.timerId = setInterval(() =&gt; {
    //   console.log('定时器触发了')
    // }, 1000)

    window.addEventListener('resize', this.handleResize)
  }

  handleResize = () =&gt; {
    console.log('窗口大小改变了')
  }

  // 组件将要卸载
  componentWillUnmount() {
    console.warn('组件生命周期钩子函数： componentWillUnmount')

    // 清理定时器
    // clearInterval(this.timerId)
    window.removeEventListener('resize', this.handleResize)
  }

  render() {
    return &lt;h1&gt;统计豆豆被打的次数：{this.props.count}&lt;/h1&gt;
  }
}
</code></pre>
<h2 id="render-props-模式的使用">render-props 模式的使用</h2>
<ul>
<li>
<p>作用：实现<strong>状态逻辑复用</strong></p>
</li>
<li>
<p>Mouse 组件的职责：</p>
<ul>
<li>1 提供了state</li>
<li>2 提供了操作状态的方法</li>
</ul>
</li>
<li>
<p>注意：Mouse 组件仅仅负责状态逻辑复用，不会指定要渲染的内容。</p>
</li>
<li>
<p>要渲染什么内容，就在复用 Mouse 组件的时候，通过 render 属性的返回值指定</p>
</li>
</ul>
<pre><code class="language-js">// 复用Mouse组件，渲染p标签：
&lt;Mouse render={mouse =&gt; &lt;p&gt;&lt;/p&gt;} /&gt;

// 复用Mouse组件，渲染img标签：
&lt;Mouse render={mouse =&gt; &lt;img src=... /&gt;} /&gt;
</code></pre>
<ul>
<li>但是，render 属性的返回值要生效，必须得在 Mouse 组件中，来处理才可以</li>
</ul>
<pre><code class="language-js">class Mouse extends React.Component {
  // ...

  render() {
    // 调用 render 这个属性，通过它的返回值，来拿到要渲染的内容
    return this.props.render(this.state)
  }
}
</code></pre>
<ul>
<li>推荐：使用 children 代替 render 属性</li>
</ul>
<pre><code class="language-js">&lt;Mouse&gt;
  {
    mouse =&gt; &lt;p&gt;{mouse.x} - {mouse.y}&lt;/p&gt;
  }
&lt;/Mouse&gt;

// 组件中：
render() {
  return this.props.children(this.state)
}
</code></pre>
<h2 id="高阶组件">高阶组件</h2>
<ul>
<li>作用：实现<strong>状态逻辑复用</strong></li>
<li>使用包装模式，也就是：使用一个组件（A）来包装另外一个组件，这样，另外一个组件中，就可以通过 props 来拿到组件A提供的状态</li>
<li>高阶组件实际上是一个函数，比如：<code>withMouse</code></li>
</ul>
<pre><code class="language-js">// 参数Cat：就是被包装的组件
// 返回值CatWithMouse：就是增强后的组件。处理后，CatWithMouse中既有结构又有鼠标位置了
const CatWithMouse = withMouse(Cat)

const withMouse = (WrappedComponent) =&gt; {
  class Mouse extends React.Component {
    // 实现状态 和 操作状态的方法

    render() {
      return &lt;WrappedComponent {...this.state} {...this.props} /&gt;
    }
  }

  return Mouse
}

&lt;CatWithMouse name=&quot;jack&quot; /&gt;
</code></pre>
<h2 id="简化受控组件的使用">简化受控组件的使用</h2>
<ul>
<li>1 在 state 中添加表单元素的状态</li>
<li>2 将 state 设置为每个表单元素的 value 值</li>
<li>3 给 表单元素 绑定 change 事件</li>
<li>4 创建 handleChange 事件处理程序，用来统一处理表单项的值</li>
<li>5 <strong>给每一个表单元素添加 name 属性，name 属性的值为：当前对应的状态名称</strong></li>
<li>6 在 handleChange 这个统一的事件处理程序中，通过 e.target.name 来获取到当前要更新的状态名称</li>
<li>7 使用 ES6 中的属性名表达式，来更新状态即可</li>
<li>注意：因为 checkbox 复选框，操作的是 checked 属性（也就是是否选中），所以，需要对 checkbox 进行特殊的处理。</li>
</ul>
<pre><code class="language-js">import React from 'react'

export default class CommentForm extends React.Component {
  // 1 提供状态
  state = {
    // 评论人
    name: '',
    // 评论内容：
    content: '',
    // city
    city: ''
  }
  
  handleChange = e =&gt; {
    const target = e.target
    // 针对于表单元素进行处理：
    const value = target.type === 'checkbox' ? target.checked : target.value

    // name 就是要更新的状态名称
    const name = target.name

    // http://es6.ruanyifeng.com/#docs/object#%E5%B1%9E%E6%80%A7%E5%90%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F
    this.setState({
      [name]: value
    })
  }

  // 发表评论：
  addComment = () =&gt; {
    const { name, content, city } = this.state
    console.log(name, content, city)
  }

  render() {
    const { name, content, city } = this.state

    return (
      &lt;div&gt;
        {/* 给每一个表单项添加 name 属性，值为：当前表单项对应的状态 */}
        &lt;input
          type=&quot;text&quot;
          placeholder=&quot;评论人&quot;
          value={name}
          name=&quot;name&quot;
          onChange={this.handleChange}
        /&gt;
        &lt;br /&gt;
        &lt;textarea
          cols=&quot;30&quot;
          rows=&quot;10&quot;
          placeholder=&quot;评论内容&quot;
          value={content}
          name=&quot;content&quot;
          onChange={this.handleChange}
        /&gt;
        &lt;br /&gt;
        &lt;select name=&quot;city&quot; value={city} onChange={this.handleChange}&gt;
          &lt;option value=&quot;1&quot;&gt;北京&lt;/option&gt;
          &lt;option value=&quot;2&quot;&gt;上海&lt;/option&gt;
          &lt;option value=&quot;3&quot;&gt;航头&lt;/option&gt;
        &lt;/select&gt;
        &lt;br /&gt;
        &lt;input
          type=&quot;checkbox&quot;
          name=&quot;isChecked&quot;
          checked={isChecked}
          onChange={this.handleChange}
        /&gt;
        &lt;button onClick={this.addComment}&gt;发表评论&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<h2 id="setstate-的说明">setState 的说明</h2>
<ul>
<li>
<p>注意：<code>setState({})</code> 方法是异步更新数据的！如果同时调用 setState() 方法多次，后面的 setState() 不要依赖于前面的 setState() 结果。</p>
</li>
<li>
<p>不管同时调用多少次 setState()，都只会触发一次重新渲染</p>
</li>
<li>
<p>推荐使用：<code>setState((state, props) =&gt; {})</code></p>
<ul>
<li>通过该语法形式，就可以做到：后面的setState()可以依赖于上面setState()的值</li>
</ul>
</li>
<li>
<p>setState() 方法由两个参数：</p>
<ul>
<li>1 第一个参数用来更新状态</li>
<li>2 第二个参数是一个回调函数，表示组件状态更新后，立即出发的操作（知道）</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 修改状态：
// setState() 是异步更新数据的
handleClick = () =&gt; {
  console.log('setState前的状态：', this.state.count)

  // 回调函数的参数：
  // 1 state 表示最新的状态
  // 2 props 表示最新的 props
  // 通过回调函数的返回值，来更新状态
  this.setState((state, props) =&gt; {
    return {
      count: state.count + 2
    }
  }, () =&gt; {})

  console.log('setState后的状态：', this.state.count)
}
</code></pre>
<h2 id="jsx-语法的转化过程">JSX 语法的转化过程</h2>
<ul>
<li>JSX -&gt; React.createElement() -&gt; JS对象（用来告诉 React 最终要渲染在页面中的内容）</li>
</ul>
<h2 id="react-组件更新机制">React 组件更新机制</h2>
<ul>
<li>特点：只要父组件更新了，那么，父组件自己以及它的所有子组件（后代组件），全部会被更新。</li>
</ul>
<h2 id="组件性能优化">组件性能优化</h2>
<h3 id="1-减轻state">1 减轻state</h3>
<ul>
<li>只把更组件渲染内容相关的数据放在 state 中
<ul>
<li>1 count（计数器）</li>
<li>2 list（评论列表数据）</li>
<li>3 loading（是否加载中，它会控制组件要渲染的内容）</li>
</ul>
</li>
<li>注意：不要把跟组件渲染无关的数据，放在 state 中，而把这些数据直接放在 this 中即可</li>
</ul>
<h3 id="2-shouldcomponentupdate">2 shouldComponentUpdate</h3>
<ul>
<li>
<p>使用场景：阻止不必要的更新</p>
</li>
<li>
<p>作用：通过返回值来决定是否重新渲染组件</p>
<ul>
<li>如果返回true，就会更新组件；</li>
<li>如果返回false，就不会更新组件</li>
</ul>
</li>
<li>
<p>参数表示最新的 props 和 state</p>
</li>
<li>
<p>可以通过 this.props 和 this.state 来获取到上一次（更新前的）的值</p>
</li>
</ul>
<pre><code class="language-js">// 第一个参数：表示最新的props值
// 第二个参数：表示最新的state值
shouldComponentUpdate(nextProps, nextState) {
  if (nextProps.count % 2 === 0) {
    // 此时为 偶数
    return false
  }
  return true
}
</code></pre>
<h3 id="3-使用纯组件">3 使用纯组件</h3>
<ul>
<li>用法：只要将 React.Component 替换为 React.PureComponent 即可</li>
<li>原理：内部会自动实现 shouldComponentUpdate 钩子函数，会分别对比 更新前后的 props 和 state，只要有一个发生变化了，就会更新组件；换句话说，也就是：如果 props 或 state，都没有改变，此时，组件就不会更新了。</li>
</ul>
<pre><code class="language-js">class Child2 extends React.PureComponent {
  render() {
    console.log('Child2 组件重新渲染了')
    return &lt;h1&gt;随机数：{this.props.number}&lt;/h1&gt;
  }
}
</code></pre>
<h3 id="纯组件内部的原理">纯组件内部的原理</h3>
<ul>
<li>原理：内部进行的是浅对比（shallow compare）</li>
<li>对于值类型，直接修改即可，没有坑</li>
<li>但是，对于引用类型来说：（只比较对象的地址）
<ul>
<li>1 如果直接修改当前对象中属性的值，那么，在更新状态的时候，即便数据变化了，组件也不会被重新渲染</li>
<li>2 应该创建新的引用类型值，再更新状态</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 1 不要这么做：
// 在 PureComponent 中，不会让组件重新渲染
const { obj } = this.state
const newObj = obj
newObj.number = number

this.setState({
  obj: newObj
})
</code></pre>
<pre><code class="language-js">// 2 正确做法：
const { obj } = this.state
// 注意：此处创建了一个新的对象 newObj
const newObj = { ...obj }
newObj.number = number

this.setState({
  obj: newObj
})
</code></pre>
<h2 id="更新组件的原则">更新组件的原则</h2>
<ul>
<li><strong>不要直接修改当前状态的值（引用类型），而是创建一个新的对象或数组</strong></li>
</ul>
<pre><code class="language-js">// 推荐修改数组值的方式：
this.setState({
  list: [...this.state.list, { ..省略对象结构 }]
})
// ES5：
// const newList = list.concat([ ... ])

// 推荐修改对象值的方式：
this.setState({
  obj: {...this.state.obj, number: ...}
})
// ES5：
// Object.assign(目标对象, 原来的状态对象, 新的状态对象)
// 当前例子中：const newObj = Object.assign({}, this.state.obj, { number: 9 })
</code></pre>
<h2 id="虚拟dom-和-diff算法">虚拟DOM 和 Diff算法</h2>
<ul>
<li>
<p>React 中一个组件的更新方式：只要调用 setState() 当前这个组件就会被更新。也就是会调用 render() 方法。</p>
<ul>
<li>但是：不是 render() 方法被调用，整个组件的内容，就会被全部更新！！！</li>
</ul>
</li>
<li>
<p>实际上，React 内部会实现：<strong>部分更新</strong>，也就是，哪个地方需要更新，只会把这个地方对应的DOM重新渲染</p>
</li>
</ul>
<h3 id="diff-算法的说明-1">Diff 算法的说明 - 1</h3>
<ul>
<li>如果两棵树的根元素类型不同，React 会销毁旧树，创建新树</li>
</ul>
<pre><code class="language-js">// 旧树
&lt;div&gt;
  &lt;Counter /&gt;
&lt;/div&gt;

// 新树
&lt;span&gt;
  &lt;Counter /&gt;
&lt;/span&gt;

执行过程：destory Counter -&gt; insert Counter
</code></pre>
<h3 id="diff-算法的说明-2">Diff 算法的说明 - 2</h3>
<ul>
<li>对于类型相同的 React DOM 元素，React 会对比两者的属性是否相同，只更新不同的属性</li>
<li>当处理完这个 DOM 节点，React 就会递归处理子节点。</li>
</ul>
<pre><code class="language-html">// 旧
&lt;div className=&quot;before&quot; title=&quot;stuff&quot;&gt;&lt;/div&gt;
// 新
&lt;div className=&quot;after&quot; title=&quot;stuff&quot;&gt;&lt;/div&gt;
只更新：className 属性

// 旧
&lt;div style={{color: 'red', fontWeight: 'bold'}}&gt;&lt;/div&gt;
// 新
&lt;div style={{color: 'green', fontWeight: 'bold'}}&gt;&lt;/div&gt;
只更新：color属性
</code></pre>
<h3 id="diff-算法的说明-3">Diff 算法的说明 - 3</h3>
<ul>
<li>1 当在子节点的后面添加一个节点，这时候两棵树的转化工作执行的很好</li>
</ul>
<pre><code class="language-js">// 旧
&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;

// 新
&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
  &lt;li&gt;third&lt;/li&gt;
&lt;/ul&gt;

执行过程：
React会匹配新旧两个&lt;li&gt;first&lt;/li&gt;，匹配两个&lt;li&gt;second&lt;/li&gt;，然后添加 &lt;li&gt;third&lt;/li&gt; tree
</code></pre>
<ul>
<li>2 但是如果你在开始位置插入一个元素，那么问题就来了：</li>
</ul>
<pre><code class="language-js">// 旧
&lt;ul&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
&lt;/ul&gt;

// 新
&lt;ul&gt;
  &lt;li&gt;3&lt;/li&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
&lt;/ul&gt;

执行过程：
React将改变每一个子节点，而非保持 &lt;li&gt;Duke&lt;/li&gt; 和 &lt;li&gt;Villanova&lt;/li&gt; 不变
</code></pre>
<h3 id="key-属性">key 属性</h3>
<blockquote>
<p>为了解决以上问题，React 提供了一个 key 属性。当子节点带有 key 属性，React 会通过 key 来匹配原始树和后来的树。</p>
</blockquote>
<pre><code class="language-js">// 旧
&lt;ul&gt;
  &lt;li key=&quot;2015&quot;&gt;1&lt;/li&gt;
  &lt;li key=&quot;2016&quot;&gt;2&lt;/li&gt;
&lt;/ul&gt;

// 新
&lt;ul&gt;
  &lt;li key=&quot;2014&quot;&gt;3&lt;/li&gt;
  &lt;li key=&quot;2015&quot;&gt;1&lt;/li&gt;
  &lt;li key=&quot;2016&quot;&gt;2&lt;/li&gt;
&lt;/ul&gt;

执行过程：
现在 React 知道带有key '2014' 的元素是新的，对于 '2015' 和 '2016' 仅仅移动位置即可
</code></pre>
<ul>
<li>说明：key 属性在 React 内部使用，但不会传递给你的组件</li>
<li>推荐：在遍历数据时，推荐在组件中使用 key 属性：<code>&lt;li key={item.id}&gt;{item.name}&lt;/li&gt;</code></li>
<li>注意：<strong>key 只需要保持与他的兄弟节点唯一即可，不需要全局唯一</strong></li>
<li>注意：<strong>尽可能的减少数组 index 作为 key，数组中插入元素的等操作时，会使得效率底下</strong></li>
</ul>
<h2 id="组件的极简模型">组件的极简模型</h2>
<ul>
<li><code>(state, props) =&gt; UI</code></li>
</ul>
<h2 id="路由的基本使用">路由的基本使用</h2>
<ul>
<li>React路由中的一切都是组件，所以，如何使用 React的组件，就如何使用 React路由。</li>
<li>1 安装：<code>yarn add react-router-dom</code></li>
<li>2 导入路由中的三个组件：<code>Router</code> / <code>Route</code> / <code>Link</code></li>
<li>3 使用 Router 组件包裹整个应用</li>
<li>4 使用 Link 组件配置路由的入口
<ul>
<li>通过 to 属性来指定 pathname（也就是浏览器地址栏中的地址）</li>
</ul>
</li>
<li>5 使用 Route 组件配置路由出口
<ul>
<li>path 属性：指定路由规则</li>
<li>component 属性：指定该路由规则匹配时要展示的组件</li>
</ul>
</li>
</ul>
<pre><code class="language-js">import { BrowserRouter as Router, Route, Link } from 'react-router-dom'

// 创建First组件
const First = () =&gt; &lt;p&gt;这是 First 组件的内容&lt;/p&gt;
const Home = () =&gt; &lt;div style={{ color: 'red' }}&gt;这是 Home 组件&lt;/div&gt;

class App extends React.Component {
  render() {
    return (
      // 3 使用 Router 组件包裹整个应用
      &lt;Router&gt;
        &lt;div&gt;
          &lt;h1&gt;使用 react 路由&lt;/h1&gt;
          {/* 4 配置路由的入口（也就是一个导航菜单） */}
          &lt;Link to=&quot;/first&quot;&gt;页面一&lt;/Link&gt;
          &lt;br /&gt;
          &lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;

          {/* 5 配置路由的出口（配置路由规则和要展示的组件） */}
          &lt;Route path=&quot;/first&quot; component={First} /&gt;

          {/* 再创建另一外一个路由： */}
          &lt;Route path=&quot;/home&quot; component={Home} /&gt;
        &lt;/div&gt;
      &lt;/Router&gt;
    )
  }
}
</code></pre>
<h2 id="react-路由使用的说明">React 路由使用的说明</h2>
<ul>
<li>Router 组件：整个应用使用<strong>一次</strong>即可！也就是用 Router 包裹整个应用</li>
<li>React 路由有两种模式：
<ul>
<li>1 使用哈希值实现（hash）： HashRouter</li>
<li>2 使用 H5 中的 history API： BrowserRouter（推荐）</li>
</ul>
</li>
<li>Link 组件：用来设置导航菜单
<ul>
<li>这个组件最终会被渲染成一个 a 标签</li>
<li>to 属性：用来指定浏览器地址栏中的 哈希值 或者 pathname</li>
</ul>
</li>
<li>Route 组件：用来设置路由规则
<ul>
<li>path 属性：配置路由规则</li>
<li>component 属性：指定要展示的组件</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// H5 中的 history API
import { BrowserRouter as Router, Route, Link } from 'react-router-dom'

// 使用 哈希值（浏览器地址栏中的 #/） 来实现路由：
import { HashRouter as Router, Route, Link } from 'react-router-dom'
</code></pre>
<h2 id="编程式导航">编程式导航</h2>
<ul>
<li>
<p>编程式导航：可以通过 JS 代码的方式，来实现路由跳转</p>
</li>
<li>
<p>组件中通过 <code>props</code> 来获取到路由信息</p>
<ul>
<li>对于函数组件来说就是通过 参数props 来获取</li>
<li>对于类组件来说，就是通过 this.props 来获取</li>
</ul>
</li>
<li>
<p><code>push(path)</code>：跳转到参数中指定的路由地址</p>
</li>
<li>
<p><code>go(n)</code>：前进（1）或后退（-1）</p>
</li>
</ul>
<pre><code class="language-js">const First = props =&gt; {
  const handleClick = () =&gt; {
    // push 方法用来实现路由的跳转
    // 参数：表示要跳转到的路由的路径
    props.history.push('/login')
  }

  return (
    &lt;p&gt;
      这是 First 组件的内容
      &lt;button onClick={handleClick}&gt;跳转到登录页面&lt;/button&gt;
    &lt;/p&gt;
  )
}
</code></pre>
<h2 id="默认路由">默认路由</h2>
<ul>
<li>默认路由地址为：<code>/</code></li>
<li>默认路由，在进入页面时，就会被匹配</li>
</ul>
<pre><code class="language-js">const Home = () =&gt; &lt;p&gt;这是首页，进入页面时，就会展示该组件内容&lt;/p&gt;
&lt;Route path=&quot;/&quot; component={Home} /&gt;
</code></pre>
<h2 id="路由匹配规则">路由匹配规则</h2>
<ul>
<li>默认情况下，路由是<strong>模糊匹配</strong>的</li>
<li>也就是说：只要 pathname 是以 path 开头，那么， 这个路由规则就会匹配成功
<ul>
<li>比如：pathname 是 '/first'，path 是 '/'，此时，pathname 是以 / 开头的，所以，此时，这个路由规则就被匹配了，也就是 会展示该规则对应的组件</li>
</ul>
</li>
</ul>
<pre><code class="language-js">&lt;Route path=&quot;/&quot; component={Home} /&gt;
</code></pre>
<h2 id="精确匹配">精确匹配</h2>
<ul>
<li>给 Route 添加 <code>exact</code> 属性，就会让当前路由规则变为精确匹配</li>
<li>此时，只有当 pathname 和 path 完全匹配时，才会展示该组件。</li>
</ul>
<pre><code class="language-js">// 精确匹配：
// pathname 是 '/first'，path 是 '/'，此时，就不会匹配了
// 只有当 pathname 是 '/' 并且 path 也是 '/' ，此时才会匹配
&lt;Route exact path=&quot;/&quot; component={Home} /&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue基础]]></title>
        <id>https://lucas-y.github.io/post/vue/</id>
        <link href="https://lucas-y.github.io/post/vue/">
        </link>
        <updated>2020-12-25T02:14:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="vue-的基本概念">vue 的基本概念</h2>
<p><a href="https://cn.vuejs.org/">vue官网</a><br>
<code>vue是一个渐进式的 javascript 框架</code></p>
<ul>
<li>渐进式  =&gt;  逐渐增强, 学一点用一点, 利于上手</li>
<li>框架:  一套完整的解决方案</li>
</ul>
<blockquote>
<p><strong>特点</strong>: 需要按照框架的规则编写代码   <strong>好处</strong>: 大大的提升了开发效率</p>
</blockquote>
<h2 id="vue3-和-vue2的区别">vue3 和 vue2的区别</h2>
<h3 id="版本说明">版本说明</h3>
<p>当前，vue 共有 3 个大版本，其中：</p>
<ul>
<li><strong><code>2.x 版本</code>的 vue 是目前企业级项目开发中的主流版本</strong></li>
<li><code>3.x 版本</code>的 vue 于 2020-09-19 正式发布，生态还不完善，尚未在企业级项目开发中普及和推广</li>
<li><code>1.x 版本</code>的 vue 几乎被淘汰，不再建议学习与使用<br>
总结:</li>
</ul>
<ol>
<li>目前进公司,  公司一定选稳定的开发模式!  主流版本一定是 vue2 (<strong>必须重点掌握</strong>)</li>
<li>vue3 虽然生态尚不完善, 没有那么普及, 但是我们可以 <strong>前瞻变化</strong> , 这是将来的趋势</li>
</ol>
<h3 id="vue3-和-vue2-的对比">vue3 和 vue2 的对比</h3>
<p>vue2.x 中绝大多数的 API 与特性，在 vue3.x 中同样支持。 (<strong>向前兼容</strong>)<br>
同时，vue3.x 中还新增了 3.x 所特有的功能, 废弃了一些旧功能</p>
<ol>
<li>新增例如：<strong><code>组合式 API (函数式编程)</code></strong>、多根节点组件、更好的 TypeScript 支持等  (ts 在原生基础上, 增加了类型检测)</li>
<li>废弃例如：<strong><code>过滤器</code></strong> 等<br>
如果是2.x的版本, 可以放心的使用过滤器<br>
如果项目已经升级到了3.x 版本的 vue，官方建议使用计算属性或方法代替被剔除的过滤器功能<br>
官方迁移指南: https://v3.vuejs.org/guide/migration/introduction.html</li>
</ol>
<h2 id="mvvm设计模式">MVVM设计模式</h2>
<p>MVVM是一种设计模式, 从后端的 MVC模式 演化而来</p>
<ul>
<li>M Model 数据模型 可以是自己准备回来的数据 也可以是请求回来的数据</li>
<li>V View 视图相关的</li>
<li>VM ViewModel 视图模型 既可以操作数据 又可以操作视图<br>
<img src="https://lucas-y.github.io//post-images/1608864082496.png" alt="" loading="lazy"></li>
</ul>
<h2 id="vue初体验">vue初体验</h2>
<ol>
<li>安装下载 vue</li>
</ol>
<pre><code class="language-txt">npm i vue
</code></pre>
<ol start="2">
<li>引入一个 vue</li>
<li>使用 vue - 初始化 vue 实例  <strong>指定视图 和 数据</strong></li>
</ol>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;h1&gt;{{ msg }}&lt;/h1&gt;
  &lt;h1&gt;{{ msg }}&lt;/h1&gt;
&lt;/div&gt;

&lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  // 只要引入 vue.js, 那么全局就有了一个Vue 构造函数
  // 创建vue实例
  const vm = new Vue({
    // 指定视图 + 数据
    // 1. el element, 用于指定vue所管理的视图范围, 值是一个选择器
    el: '#app',
    // 2. data, 用于指定vue中可以使用的数据
    data: {
      msg: '你好, vue'
    }
  })
&lt;/script&gt;
</code></pre>
<h2 id="vue使用的注意点">vue使用的注意点</h2>
<ol>
<li>new Vue() 构造函数Vue, 首字母大写</li>
<li>el 不能指定为 html 和 body, 但是可以是一个大的div</li>
<li>到了vue, 不要老想着操作dom了, <code>要更新视图, 操作数据即可</code></li>
</ol>
<h2 id="vue的插值表达式">vue的插值表达式</h2>
<p>插值表达式, 小胡子语法<code>{{ }}</code></p>
<ol>
<li>作用:  使用 data 中的数据渲染视图</li>
<li>基本语法, 支持三元运算符<pre><code class="language-jsx">{{ msg }}
{{ obj.name }}
{{ msg.toUpperCase() }}
{{ obj.age &gt; 18 ? '成年' : '未成年' }}
</code></pre>
</li>
<li>vue中插值表达式的注意点<br>
(1)  使用的数据在 data 中要存在<pre><code class="language-jsx">&lt;h1&gt;{{ gaga }}&lt;/h1&gt;
</code></pre>
(2)  能使用表达式, 但是不能使用 if  for<pre><code class="language-jsx">&lt;h1&gt;{{ if (obj.age &gt; 18 ) { }   }}&lt;/h1&gt;
</code></pre>
(3)  不能在标签属性中使用<pre><code class="language-jsx">&lt;h1 id=&quot;box&quot; class=&quot;box&quot; title=&quot;{{ msg }}&quot;&gt;&lt;/h1&gt;
</code></pre>
</li>
</ol>
<h2 id="vue指令">vue指令</h2>
<p><strong>vue指令, 实质上就是特殊的 html 标签属性, 特点:  v- 开头</strong><br>
每个 v- 开头的指令, 都有着自己独立的功能, 将来vue解析时, 会根据不同的指令提供不同的功能</p>
<h3 id="v-text-和-v-html">v-text 和 v-html</h3>
<ul>
<li>v-text 设置元素的 innerText, 不识别标签, 基本可以被 插值表达式 替代, 不太常用</li>
<li>v-html 设置元素的 innerHTML, 可以识别标签,  需要识别标签的时候, 使用v-html即可</li>
</ul>
<h3 id="v-if-和-v-show">v-if 和 v-show</h3>
<p>v-show 和 v-if 功能: 控制盒子的显示隐藏</p>
<ol>
<li>v-show<br>
语法:  v-show=&quot;布尔值&quot;    (true显示, false隐藏)<br>
原理:  实质是在控制元素的 css 样式,  <code>display: none;</code></li>
<li>v-if<br>
语法: v-if=&quot;布尔值&quot;   (true显示, false隐藏)<br>
原理:  实质是在动态的创建 或者 删除元素节点<br>
应用场景:</li>
</ol>
<ul>
<li>如果是频繁的切换显示隐藏, 用 v-show<br>
v-if, 频繁切换会大量的创建和删除元素, 消耗性能</li>
<li>如果是不用频繁切换, 要么显示, 要么隐藏的情况, 适合于用 v-if<br>
v-if 是<code>惰性</code>的, 如果初始值为 false, 那么这些元素就直接不创建了, 节省一些初始渲染开销</li>
</ul>
<h3 id="v-if-v-else-if-v-else">v-if v-else-if v-else</h3>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;h1 v-if=&quot;isLogin&quot;&gt;尊敬的超级vip, 你好&lt;/h1&gt;
  &lt;h1 v-else&gt;你谁呀, 赶紧登陆~&lt;/h1&gt;
  &lt;hr&gt;
  &lt;h1 v-if=&quot;age &gt;= 60&quot;&gt;60岁以上, 广场舞&lt;/h1&gt;
  &lt;h1 v-else-if=&quot;age &gt;= 30&quot;&gt;30岁以上, 搓麻将&lt;/h1&gt;
  &lt;h1 v-else-if=&quot;age &gt;= 20&quot;&gt;20岁以上, 蹦迪&lt;/h1&gt;
  &lt;h1 v-else&gt;20岁以下, 唱跳rap篮球&lt;/h1&gt;
&lt;/div&gt;

&lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  const vm = new Vue({
    el: '#app',
    data: {
      msg: 'hello vue',
      isLogin: true,
      age: 18
    }
  })
&lt;/script&gt;
</code></pre>
<h3 id="v-on指令">v-on指令</h3>
<ol>
<li>用于注册事件</li>
</ol>
<ul>
<li>写内联语句, 将要执行的代码直接写在 &quot;&quot; 内部, 适合写少量代码<br>
v-on:事件名=&quot;要执行的代码&quot;</li>
<li>指向methods中的定义的函数<br>
v-on:事件名=&quot;methods中的函数&quot;</li>
<li>指向methods中的定义的函数，并传入参数<br>
v-on:事件名=&quot;methods中的函数(实参)&quot;<br>
<code>简写: @事件名</code></li>
</ul>
<ol start="2">
<li>vue中获取事件对象</li>
</ol>
<blockquote>
<p>需求: 默认a标签点击会跳走,  希望阻止默认的跳转, 阻止默认行为  e.preventDefault()</p>
</blockquote>
<ul>
<li>没有传参, 通过形参接收 e</li>
<li>传参了, 通过$event指代事件对象 e</li>
</ul>
<ol start="3">
<li>事件修饰符</li>
</ol>
<ul>
<li><code>.prevent</code> 阻止默认行为</li>
<li><code>.stop</code> 阻止冒泡</li>
</ul>
<ol start="4">
<li>案件修饰符</li>
</ol>
<blockquote>
<p>在监听键盘事件时，我们经常需要判断详细的按键。此时，可以为键盘相关的事件添加按键修饰符</p>
</blockquote>
<ul>
<li><code>@keyup.enter</code>  回车触发</li>
<li><code>@keyup.esc</code>  返回触发</li>
</ul>
<h3 id="v-bind指令">v-bind指令</h3>
<p><strong>作用: 访问data中的数据,  动态的设置html的标签属性</strong><br>
语法: <code>v-bind:属性名=&quot;值&quot;</code> ,  简写 <code>:属性名=&quot;值&quot;</code></p>
<ul>
<li>v-bind 对于类名操作的增强, 注意点, :class 不会影响到原来的 class 属性<br>
:class=&quot;对象/数组&quot;</li>
</ul>
<pre><code class="language-js">(1) :class=&quot;对象&quot; 
	{ 类名: 布尔值, 类名: 布尔值 } 
	如果是true, 加上这个类, 如果是false, 移除这个类

(2) :class=&quot;数组&quot;
	['类名1', '类名2', '类名3']
	只要有这个类, 就加上

(3) :class=&quot;对象/数组&quot; 直接内联在结构中编写 (重点)
</code></pre>
<ul>
<li>v-bind对于style 的增强</li>
</ul>
<pre><code>:style=&quot;对象&quot;  =&gt; :style=&quot;obj&quot;  =&gt;  :style=&quot;{ width: '200px' }&quot;
</code></pre>
<h3 id="v-for">v-for</h3>
<p>遍历对象和数组</p>
<ol>
<li>遍历数组 (常用)</li>
</ol>
<pre><code class="language-txt">v-for=&quot;item in 数组名&quot;  item每一项
v-for=&quot;(item, index) in 数组名&quot;  item每一项 index下标
</code></pre>
<ol start="2">
<li>遍历对象 (一般不用)</li>
</ol>
<pre><code class="language-txt">v-for=&quot;(value, prop) in 对象&quot;  value属性值, prop属性名
</code></pre>
<ol start="3">
<li>v-for 的key的说明</li>
</ol>
<ul>
<li>vue 的更新机制的说明<br>
数据变化了, vue会对比<code>新旧 虚拟 dom</code>的差异,  对比出差异, 进行差异化更新 (高效)</li>
<li>为啥不对比真实dom, 而对比虚拟dom?  =&gt;  提升对比效率</li>
<li>key 只是给 虚拟dom 添加了一个唯一的标识, 改变了同级兄弟元素的对比复用策略, 进而优化列表的渲染更新性能<br>
<code>总结</code>: 一般为了优化渲染的性能, 可以在遍历列表时, 加上一个 key属性, key一般指定成 id</li>
</ul>
<h3 id="v-model">v-model</h3>
<p>**作用: 给表单元素使用, 双向数据绑定 **<br>
<strong>语法: v-model='值'</strong></p>
<ol>
<li>
<p>数据变化了, 视图会跟着变<br>
数据劫持(监听数据的变化)<br>
vue2: Object.defineProperty<br>
vue3: proxy</p>
</li>
<li>
<p>视图变化了, 数据要跟着变<br>
输入框内容变化了(监听用户的输入, 监听input事件), 数据要跟着变</p>
</li>
<li>
<p>v-model 处理其他表单元素<br>
<strong>v-model 会忽略掉表单元素原本的value, checked等初始值</strong><br>
<code>textarea, select, checkbox</code></p>
</li>
</ol>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt;
  &lt;hr&gt;
  &lt;textarea v-model=&quot;desc&quot;&gt;&lt;/textarea&gt;
  &lt;p&gt;{{ desc }}&lt;/p&gt;
  &lt;hr&gt;
  &lt;!-- select框的value值, 就是选中的option的value值 
       1. 可以用于获取
       2. 还可以用于设置
  --&gt;
  &lt;select v-model=&quot;cityId&quot;&gt;
    &lt;option value=&quot;1&quot;&gt;上海&lt;/option&gt;
    &lt;option value=&quot;2&quot;&gt;无锡&lt;/option&gt;
    &lt;option value=&quot;3&quot;&gt;香港&lt;/option&gt;
    &lt;option value=&quot;4&quot;&gt;北京&lt;/option&gt;
    &lt;option value=&quot;5&quot;&gt;哈尔滨&lt;/option&gt;
    &lt;option value=&quot;6&quot;&gt;齐齐哈尔&lt;/option&gt;
  &lt;/select&gt;
  &lt;p&gt;{{ cityId }}&lt;/p&gt;
  &lt;hr&gt;
  &lt;input type=&quot;checkbox&quot; v-model=&quot;flag&quot;&gt;
  &lt;p&gt;{{ flag }}&lt;/p&gt;
&lt;/div&gt;

&lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  // 注意点: v-model设置了之后, 会忽略掉默认设置的value, checked等属性
  // 表单元素小练习
  // 1. textarea  value
  // 2. select/option  value
  // 3. checkbox复选框  checked属性

  const vm = new Vue({
    el: '#app',
    data: {
      msg: '123456',
      desc: '今天天气还行',
      cityId: 6,
      flag: false
    }
  })
&lt;/script&gt;
</code></pre>
<ol start="4">
<li>v-model 修饰符</li>
</ol>
<ul>
<li>
<p>number<br>
如果想自动将用户的输入值, 用parseFloat转成数字类型, ，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符：</p>
<pre><code class="language-html">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;
</code></pre>
<p>如果这个值如果这个值无法转数字，则会返回原始的值。</p>
</li>
<li>
<p>trim<br>
如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符：</p>
<pre><code class="language-html">&lt;input v-model.trim=&quot;msg&quot;&gt;
</code></pre>
</li>
<li>
<p>lazy<br>
在<code>change</code>时而非<code>input</code>时更新，可以给 <code>v-model</code> 添加 <code>lazy</code> 修饰符：<br>
对于 input:text 文本框, 监听用户的修改</p>
<blockquote>
<p>change   失去焦点 或 用户回车, 确认改完了触发 (了解);  input    只要用户输入了, 实时触发</p>
</blockquote>
<pre><code class="language-html">&lt;input v-model.lazy=&quot;msg&quot;&gt;
</code></pre>
</li>
</ul>
<ol start="5">
<li>如何实现v-model<br>
v-model 其实是 vue 给你提供的一种简化表单元素操作的语法糖<br>
**本质上做了两件事 **</li>
</ol>
<ul>
<li>动态设置表单元素的值</li>
</ul>
<pre><code class="language-jsx">&lt;input type=&quot;checkbox&quot; class=&quot;custom-control-input&quot; :id=&quot;'switch' + item.id&quot; :checked=&quot;item.state&quot; @change=&quot;changeState(item, $event)&quot;&gt;
</code></pre>
<ul>
<li>监听对应的事件, 表单元素值变化时, 更新到绑定的变量中</li>
</ul>
<pre><code class="language-jsx">changeState (item, e) {
  item.state = e.target.checked
}
</code></pre>
<h2 id="过滤器">过滤器</h2>
<h3 id="过滤器的兼容性">过滤器的兼容性</h3>
<blockquote>
<p>vue2.0 中推荐使用过滤器, 处理格式<br>
vue3.0 移除了过滤器, vue3.0 内部进行性能优化, 可以直接调用方法,  就可以解决之前过滤器的需求, 所以废弃了</p>
</blockquote>
<h3 id="过滤器的基本使用">过滤器的基本使用</h3>
<p>过滤器的作用: 转换格式<br>
过滤器本质上就是一个函数</p>
<pre><code>格式x --- 过滤器 -----&gt; 格式y
</code></pre>
<p>将来开发过程中, 肯定会有对于字符串进行处理转换的需求, vue中提供了一个专门的语法: 过滤器</p>
<ol>
<li>定义过滤器<br>
Vue.filter(过滤器名字, 处理字符串的函数)<br>
(1) 函数的返回值, 就是处理字符串的结果<br>
(2) 函数的形参, 可以拿到处理的字符串</li>
<li>使用过滤器 <code>{{ msg | 过滤器名字 }}</code></li>
</ol>
<h3 id="利用过滤器处理日期">利用过滤器处理日期</h3>
<p>moment官网文档: http://momentjs.cn/docs/#/displaying/<br>
<img src="https://lucas-y.github.io//post-images/1608949217588.png" alt="" loading="lazy"><br>
<img src="https://lucas-y.github.io//post-images/1608949250606.png" alt="" loading="lazy"><br>
<img src="https://lucas-y.github.io//post-images/1608949256751.png" alt="" loading="lazy"></p>
<h3 id="过滤器的参数">过滤器的参数</h3>
<p>使用过滤器支持传参</p>
<pre><code>{{ msg | 过滤器名字(参数1, 参数2) }}
</code></pre>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;h1&gt;{{ date1 | time(&quot;YYYY-MM-DD&quot;) }}&lt;/h1&gt;
  &lt;h2&gt;{{ date2 | time }}&lt;/h2&gt;
  &lt;h2&gt;{{ date2 | time }}&lt;/h2&gt;
&lt;/div&gt;

&lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;./node_modules/moment/moment.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  Vue.filter('time', function(value, str='YYYY年MM月DD日 HH:mm:ss') {
    return moment(value).format(str)
  })

  const vm = new Vue({
    el: '#app',
    data: {
      date1: 1601305782038,
      date2: 1201305782038
    }
  })
&lt;/script&gt;
</code></pre>
<h3 id="全局过滤器-和-局部过滤器">全局过滤器 和 局部过滤器</h3>
<p>全局过滤器: 在所有的vue实例中, 都可以使用<br>
局部过滤器: 只能在当前的vue实例中, 使用</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;h1&gt;{{ msg | global | demo }}&lt;/h1&gt;
&lt;/div&gt;

&lt;div id=&quot;app2&quot;&gt;
  &lt;h1&gt;{{ msg | global | demo }}&lt;/h1&gt;
&lt;/div&gt;

&lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  // 全局过滤器: 在所有的vue实例中, 都可以使用 
  // 局部过滤器: 只能在当前的vue实例中, 使用
  Vue.filter('global', function(value) {
    return value + '_global'
  })

  const vm = new Vue({
    el: '#app',
    data: {
      msg: 'hello vue'
    },
    filters: {
      // 过滤器名字: 处理函数
      demo: function(value) {
        return value + '_demo'
      }
    }
  })

  const vm2 = new Vue({
    el: '#app2',
    data: {
      msg: 'hello vue2'
    }
  })
&lt;/script&gt;
</code></pre>
]]></content>
    </entry>
</feed>