<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lucas-y.github.io/</id>
    <title>前端小白</title>
    <updated>2021-01-14T02:50:53.098Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lucas-y.github.io/"/>
    <link rel="self" href="https://lucas-y.github.io/atom.xml"/>
    <subtitle>知行合一</subtitle>
    <logo>https://lucas-y.github.io/images/avatar.png</logo>
    <icon>https://lucas-y.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 前端小白</rights>
    <entry>
        <title type="html"><![CDATA[单页应用程序-组件化]]></title>
        <id>https://lucas-y.github.io/post/vue-dan-ye-ying-yong-cheng-xu/</id>
        <link href="https://lucas-y.github.io/post/vue-dan-ye-ying-yong-cheng-xu/">
        </link>
        <updated>2021-01-13T12:25:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="单页应用程序">单页应用程序</h1>
<h2 id="单页应用程序-spa">单页应用程序 SPA</h2>
<p><strong>单页Web应用（single page web application，SPA）</strong> <strong>只有一张Web页面的应用,  所有的功能在一个页面上实现</strong></p>
<figure data-type="image" tabindex="1"><img src="https://lucas-y.github.io//post-images/1610540930245.png" alt="" loading="lazy"></figure>
<p>location.href = 'login.html'</p>
<p>多页面应用程序: 京东   https://miaosha.jd.com/</p>
<p>单页面应用程序: 网易云  https://music.163.com/   切换时, 不跳转页面</p>
<h2 id="spa-项目优缺点">SPA 项目优缺点</h2>
<p>SPA 单页面应用程序最显著的 3 个优点如下：</p>
<ol>
<li><strong>良好的交互体验</strong>
<ul>
<li><strong>单页应用的内容的改变,  不需要重新加载整个页面</strong></li>
<li>获取数据也是通过 Ajax 异步获取</li>
<li>没有页面之间的跳转 location.href ，不会出现“白屏现象”</li>
</ul>
</li>
<li>良好的前后端工作分离模式
<ul>
<li>后端专注于提供 API 接口，更易实现 API 接口的复用</li>
<li>前端专注于页面的渲染，更利于前端工程化的发展</li>
</ul>
</li>
<li>减轻服务器的压力
<ul>
<li>服务器只提供数据，不负责页面的合成与逻辑的处理，压力更小</li>
<li>每次请求, 仅仅是请求必须的内容, 效率很高,  css样式, 基本的js在第一次加载页面后, 就已经加载完了</li>
</ul>
</li>
</ol>
<p>缺点:</p>
<ul>
<li><strong>首屏加载会相对较慢</strong>, 因为一上来加载了所有的资源 (后面讲)
<ul>
<li>配置异步组件, 按需加载</li>
<li>CDN加速 (花钱加速)</li>
<li>文件压缩  (减少体积)</li>
</ul>
</li>
<li><strong>不利于 SEO</strong> 搜索引擎优化
<ul>
<li>花钱推广</li>
<li>SSR 服务器端渲染   (稍微好一点)</li>
</ul>
</li>
</ul>
<h2 id="快速创建工程化的环境">快速创建工程化的环境</h2>
<p>vue 官方提供了两种快速创建工程化的 SPA 项目的方式：</p>
<ul>
<li>基于 <strong>vite</strong> 创建 SPA 项目  (尤雨溪新作)</li>
<li>基于 <strong>vue-cli</strong> 创建 SPA 项目 (底层webpack)</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://lucas-y.github.io//post-images/1610541752100.png" alt="" loading="lazy"></figure>
<p>vite  轻量, 快,  适合进行demo的学习</p>
<p>vue-cli  =&gt;  webpack,  重, 大, 适合于企业级项目</p>
<h1 id="vite-的使用">vite 的使用</h1>
<h2 id="vite-的基本使用">vite 的基本使用</h2>
<p>按照顺序执行如下的命令，即可基于 vite 创建 vue 3.x 的工程化项目</p>
<pre><code>npm init vite-app 项目名称

cd 项目名称
yarn
yarn dev
</code></pre>
<p>输入地址, 启动项目:</p>
<figure data-type="image" tabindex="3"><img src="https://lucas-y.github.io//post-images/1610541942053.png" alt="" loading="lazy"></figure>
<h2 id="梳理项目结构">梳理项目结构</h2>
<h3 id="整体目录">整体目录</h3>
<p>使用 vite 创建的项目结构如下：</p>
<figure data-type="image" tabindex="4"><img src="https://lucas-y.github.io//post-images/1610541974883.png" alt="" loading="lazy"></figure>
<p>其中：</p>
<ul>
<li>node_modules 目录用来存放第三方依赖包</li>
<li>public 是公共的静态资源目录</li>
<li>src 是项目的源代码目录（程序员写的所有代码都要放在此目录下）</li>
<li>.gitignore 是 Git 的忽略文件</li>
<li>index.html 是 SPA 单页面应用程序中唯一的HTML 页面</li>
<li>package.json 是项目的包管理配置文件</li>
</ul>
<h3 id="src-目录介绍">src 目录介绍</h3>
<p>在 src  <strong>项目源代码目录</strong> 之下，包含了如下内容：</p>
<figure data-type="image" tabindex="5"><img src="https://lucas-y.github.io//post-images/1610545125652.png" alt="" loading="lazy"></figure>
<ul>
<li>assets 目录用来存放项目中所有的静态资源文件（css、fonts等）</li>
<li>components 目录用来存放项目中所有的自定义组件</li>
<li>App.vue 是项目的根组件</li>
<li>index.css 是项目的全局样式文件</li>
<li>main.js 是整个项目的打包入口文件</li>
</ul>
<h2 id="vite-项目运行的流程">vite 项目运行的流程</h2>
<p>在工程化的vite项目中，vue 默认做的事情很单纯：<strong>通过 main.js 把 App.vue 渲染到 index.html 的指定区域中</strong>。</p>
<p>(安装vetur插件,  <code>.vue 文件</code>高亮)</p>
<p>其中：</p>
<ul>
<li>App.vue 用来编写待渲染的模板结构</li>
<li>index.html 中需要预留一个 el 区域</li>
<li>main.js 把 App.vue 渲染到了 index.html 所预留的区域中</li>
</ul>
<pre><code class="language-jsx">import { createApp } from 'vue'
import App from './App.vue'
import './index.css'

// 将 App.vue 的内容, 渲染到 index.html中
// 1. 在 App.vue 中编写待渲染的结构
// 2. index.html 中预留一个 el 区域
// 3. main.js 将App.vue渲染到index.html的el区域

// 调用createApp()函数, 就是在创建一个单页应用实例, 通过.mount方法, 渲染到el区域中
const app = createApp(App)
app.mount('#app')
</code></pre>
<h2 id="梳理-vite-项目运行的流程">梳理 vite 项目运行的流程</h2>
<p>1 清空src目录, 新建 main.js 和 App.vue 文件</p>
<p>2 修改 App.vue 的默认内容，并书写如下的模板结构</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;h1&gt;我是App根级别组件&lt;/h1&gt;
&lt;/template&gt;
</code></pre>
<p>3 打开 index.html 页面，确认预留了 el 区域</p>
<pre><code class="language-jsx">&lt;!-- vue所管理的视图范围 --&gt;
&lt;div id=&quot;box&quot;&gt;
  &lt;!-- 这里不写任何内容, 而是通过 App.vue 组件渲染 --&gt;
&lt;/div&gt;
&lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>4 按照 vue3 的标准用法, 将 App.vue 模板内容渲染到 index.html 页面的 el 区域中</p>
<pre><code class="language-jsx">// 1. 从 vue 中按需导入 createApp 函数
//    createApp 函数的作用: 可以创建 vue 的单页应用实例
import { createApp } from 'vue'

// 2. 导入待渲染的 App 组件
import App from './App.vue'

// 3. 调用 createApp () 函数, 创建 单页应用程序实例
const app = createApp(App)

// 4. 调用 实例的 .mount 方法, 指定vue要控制的视图区域
app.mount('#box')
</code></pre>
<p>注意: template 仅仅是一个包裹容器, 不会生成任何实质性的结构</p>
<h1 id="组件化开发">组件化开发</h1>
<h2 id="什么是组件化开发">什么是组件化开发</h2>
<p><strong>组件化开发</strong> 指的是：根据封装的思想，把页面上 <code>可重用的部分</code> 封装为 <code>组件</code>，从而方便项目的 开发 和 维护。</p>
<p><strong>一个页面， 可以拆分成一个个组件，一个组件就是一个整体, 每个组件可以有自己独立的 结构 样式 和 行为</strong></p>
<p>例如：http://www.ibootstrap.cn/ 所展示的效果，就契合了组件化开发的思想。</p>
<p>用户可以通过拖拽组件的方式，快速生成一个页面的布局结构。</p>
<p>前端组件化开发的好处主要体现在以下两方面：</p>
<ul>
<li>
<p>提高了前端代码的<strong>复用性和灵活性</strong></p>
</li>
<li>
<p>提升了开发效率和后期的<strong>可维护性</strong></p>
</li>
</ul>
<p>vue 是一个完全支持组件化开发的框架。vue 中规定组件的后缀名是 .vue。</p>
<p>之前接触到的 App.vue 文件本质上就是一个 vue 的组件。</p>
<h2 id="单文件组件的三大组成部分">单文件组件的三大组成部分</h2>
<p>每个 .vue 组件都由 3 部分构成，分别是：</p>
<ul>
<li>template -&gt; 组件的模板结构</li>
<li>script -&gt; 组件的 JavaScript 行为</li>
<li>style -&gt; 组件的样式</li>
</ul>
<p>其中，<strong>每个组件中必须包含 template 模板结构</strong>，而 script 行为和 style 样式是可选的组成部分。</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;h1&gt;我是App根级别组件&lt;/h1&gt;
&lt;/template&gt;

&lt;script&gt;
// 在script中, 需要默认导出一个组件的配置对象
export default {
  
}
&lt;/script&gt;

&lt;style&gt;
h1 {
  color: red;
}
&lt;/style&gt;
</code></pre>
<p>该组件可以在其他文件中导入, <strong>注意导入的是整个整体</strong></p>
<pre><code class="language-jsx">// 导入 App 组件 (结构 样式 行为)
import App from './App.vue'
</code></pre>
<h2 id="组件的-template-说明">组件的 template 说明</h2>
<p>每个组件对应的 <code>模板结构</code>，需要定义到 <code>&lt;template&gt;</code> 节点中。</p>
<p>注意：</p>
<ol>
<li>
<p><code>&lt;template&gt;</code> 是 vue 提供的容器标签，只起到包裹性质的作用，它不会被渲染为真正的 DOM 元素。</p>
</li>
<li>
<p>在 template 定义根节点 (了解)</p>
<p>在 vue 3.x 的版本中，<code>&lt;template&gt;</code> 节点内的 DOM 结构支持多个根节点。</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;h1&gt;我是App根级别组件&lt;/h1&gt;
  &lt;h1&gt;我是另外一个根节点&lt;/h1&gt;
&lt;/template&gt;
</code></pre>
<p>但是，在 vue 2.x 的版本中，<code>&lt;template&gt;</code>节点内的 DOM 结构仅支持单个根节点，不支持多个根节点</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;h1&gt;我是App根级别组件&lt;/h1&gt;
&lt;/template&gt;
</code></pre>
</li>
</ol>
<h2 id="组件的-script-说明">组件的 script 说明</h2>
<p>组件内的 <code>&lt;script&gt;</code>节点是可选的，开发者可以在 <code>&lt;script&gt;</code>节点中封装组件的 JavaScript 业务逻辑。</p>
<pre><code class="language-html">&lt;script&gt;
// 在script中, 需要默认导出一个组件的配置对象
export default {
  
}
&lt;/script&gt;
</code></pre>
<p><strong>1 script 中的 <code>name</code> 节点</strong></p>
<p>可以通过 name 节点为当前组件定义一个名称：</p>
<pre><code class="language-jsx">export default {
  name: 'MyApp'
}
</code></pre>
<p>在使用 vue-devtools 进行项目调试的时候，自定义的组件名称可以清晰的区分每个组件：</p>
<figure data-type="image" tabindex="6"><img src="https://lucas-y.github.io//post-images/1610547044968.png" alt="" loading="lazy"></figure>
<p><strong>2 scripts 中的 <code>data</code> 节点</strong></p>
<p>vue 组件渲染期间需要用到的数据，可以定义在data 节点中：</p>
<pre><code class="language-jsx">export default {
  name: 'MyApp',
  data () {
    return {
      username: '嘎嘎'
    }
  }
}
</code></pre>
<p>vue中规定: <strong>组件中的 data 必须是函数,</strong> 不能直接指向一个数据对象。</p>
<p>因此在组件中定义 data 数据节点时，下面的方式是错误的：</p>
<pre><code class="language-jsx">data: {
  count: 0  // 错误, 不能让 data 指向一个数据对象
}
</code></pre>
<p>会导致多个组件实例共用同一份数据的问题，请参考官方给出的示例：<a href="https://cn.vuejs.org/v2/guide/components.html#data-%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0">官网地址</a></p>
<p><strong>3 script 中的 <code>methods</code> 节点</strong></p>
<p>组件中的处理函数，要声明到 methods 节点中，示例代码如下:</p>
<pre><code class="language-jsx">export default {
  name: 'MyApp',
  data () {
    return {
      username: '嘎嘎'
    }
  },
  methods: {
    fn () {
      console.log('123')
    }
  }
}
</code></pre>
<h2 id="组件的-style-说明">组件的 style 说明</h2>
<h3 id="基本说明">基本说明</h3>
<p>组件内的 <code>&lt;style&gt;</code> 节点是可选的，开发者可以在 <code>&lt;style&gt;</code>节点中编写样式美化当前组件的 UI 结构</p>
<p>其中 <code>&lt;style&gt;</code>标签上的 lang=&quot;css&quot; 属性是可选的，它表示所使用的样式语言。</p>
<p>默认只支持普通的 css 语法，可选值还有 less、sass/scss 、 stylus等。</p>
<pre><code class="language-css">&lt;style lang=&quot;css&quot;&gt;
h1 {
  color: blue;
}
&lt;/style&gt;
</code></pre>
<h3 id="让-style-中支持-less-语法">让 style 中支持 less 语法</h3>
<p>如果希望使用 less 语法编写组件的 style 样式，可以按照如下两个步骤进行配置：</p>
<ul>
<li>运行 yarn add less -D 命令安装依赖包，从而提供 less 语法的编译支持</li>
<li>在 <code>&lt;style&gt;</code> 标签上添加 <code>lang=&quot;less&quot;</code>属性，即可使用 less 语法编写组件的样式</li>
</ul>
<pre><code class="language-less">&lt;style lang=&quot;less&quot;&gt;
@color: red;
div {
  color: @color;
}
&lt;/style&gt;
</code></pre>
<h2 id="组件的注册">组件的注册</h2>
<p>刚才我们创建使用的是 App.vue 根组件, 这个比较特殊, 是最大的一个根组件</p>
<p>而App.vue根组件内, 还可以写入一些小组件, 而这些组件, 要使用, 就需要先注册!</p>
<figure data-type="image" tabindex="7"><img src="https://lucas-y.github.io//post-images/1610547112428.png" alt="" loading="lazy"></figure>
<p><strong>注册组件有两种注册方式</strong>:  分为“全局注册”和“局部注册”两种</p>
<ul>
<li>被全局注册的组件，可以在任意的组件模板范围中使用          (每个组件都是一个vue实例)</li>
<li>被局部注册的组件，只能在当前注册的组件模板范围内使用</li>
</ul>
<h3 id="全局组件">全局组件</h3>
<p>全局注册: 被全局注册的组件，可以在任意的组件模板范围中使用</p>
<p>1 新建 components 文件夹, 准备三个文件 <code>hm-header.vue</code>    <code>hm-main.vue</code>    <code>hm-footer.vue</code></p>
<pre><code class="language-less">&lt;template&gt;
  &lt;div class=&quot;hm-header&quot;&gt;头部&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {

}
&lt;/script&gt;

&lt;style lang=&quot;less&quot;&gt;
.hm-header {
  height: 50px;
  border: 3px solid #000;
  padding: 20px;
  margin-bottom: 20px;
}
&lt;/style&gt;
</code></pre>
<p>2 在 <code>main.js</code> 中导入</p>
<pre><code class="language-jsx">// .vue文件中, 提供了组件的配置项, 将来基于这个配置项, 可以注册组件, 就可以当成html标签使用
import HmHeader from './components/hm-header.vue'
</code></pre>
<p>3 全局注册</p>
<pre><code class="language-jsx">// 全局注册组件
app.component('hm-header', HmHeader)
</code></pre>
<p>4 使用组件 =&gt;  注册好的组件, 可以当成 html 标签使用</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;hm-header&gt;&lt;/hm-header&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://lucas-y.github.io//post-images/1610547150224.png" alt="" loading="lazy"></figure>
<h3 id="局部注册">局部注册</h3>
<p>局部注册: 被局部注册的组件，只能在当前注册的组件模板范围内使用</p>
<p>1 在 App.vue 中导入</p>
<pre><code class="language-jsx">import HmHeader from './components/hm-header.vue'
import HmMain from './components/hm-main.vue'
import HmFooter from './components/hm-footer.vue'
</code></pre>
<p>2 局部注册</p>
<pre><code class="language-jsx">export default {
  name: 'MyApp',
  components: {
    'hm-header': HmHeader,
    'hm-main': HmMain,
    'hm-footer': HmFooter
  }
}
</code></pre>
<p>3 使用局部注册的组件</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;hm-header&gt;&lt;/hm-header&gt;
    &lt;hm-main&gt;&lt;/hm-main&gt;
    &lt;hm-footer&gt;&lt;/hm-footer&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h3 id="组件名的大小写">组件名的大小写</h3>
<p>在进行组件的注册时，定义组件名的方式有两种：</p>
<ul>
<li>
<p>注册使用短横线命名法，例如 hm-header 和 hm-main</p>
<pre><code class="language-js">app.component('hm-button', HmButton)
</code></pre>
<p>使用时 <code>&lt;hm-button&gt; &lt;/hm-button&gt;</code></p>
</li>
<li>
<p>注册使用大驼峰命名法，例如 HmHeader 和 HmMain</p>
<pre><code class="language-jsx">app.component('HmButton', HmButton)
</code></pre>
<p>使用时 <code>&lt;HmButton&gt; &lt;/HmButton&gt;</code> 和 <code>&lt;hm-button&gt; &lt;/hm-button&gt;</code>  都可以</p>
</li>
</ul>
<p>推荐定义组件名时, 用大驼峰命名法, 更加方便</p>
<p>全局注册</p>
<pre><code class="language-jsx">app.component('HmButton', HmButton)
</code></pre>
<p>局部注册:</p>
<pre><code class="language-jsx">components: {
  HmHeader,
  HmMain,
  HmFooter
}
</code></pre>
<p>使用时, 推荐遵循html5规范, 小写横杠隔开</p>
<pre><code class="language-jsx">&lt;hm-header&gt;&lt;/hm-header&gt;
&lt;hm-main&gt;&lt;/hm-main&gt;
&lt;hm-footer&gt;&lt;/hm-footer&gt;
</code></pre>
<h3 id="通过-name-注册组件-了解">通过 name 注册组件 (了解)</h3>
<p>在注册组件期间，除了可以直接提供组件的注册名称之外，还可以把组件的 name 属性作为注册后组件的名称</p>
<p>组件内容:</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;button&gt;按钮组件&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'HmButton'
}
&lt;/script&gt;

&lt;style lang=&quot;less&quot;&gt;
button {
  width: 80px;
  height: 50px;
  border-radius: 5px;
  background-color: pink;
}
&lt;/style&gt;
</code></pre>
<p>进行注册:</p>
<pre><code class="language-jsx">import HmButton from './components/hm-button.vue'
app.component(HmButton.name, HmButton)  // 等价于 app.component('HmButton', HmButton)
</code></pre>
<h2 id="组件的样式冲突-scoped">组件的样式冲突  <code>scoped</code></h2>
<p>默认情况下，写在组件中的样式会<code>全局生效</code>，因此很容易造成多个组件之间的样式冲突问题。</p>
<p>根本原因是：单页应用程序中，所有组件的结构，都是基于唯一的 index.html 页面进行呈现的,</p>
<p>组件样式默认会作用到全局, 就会影响到整个 index.html 中的 dom 元素</p>
<ul>
<li>
<p><code>全局样式</code>: 默认组件中的样式会作用到全局</p>
</li>
<li>
<p><code>局部样式</code>: 可以给组件加上 scoped 属性, 可以让样式只作用于当前组件</p>
</li>
</ul>
<pre><code class="language-jsx">&lt;style lang=&quot;less&quot; scoped&gt;
div {
  background-color: pink;
}
&lt;/style&gt;
</code></pre>
<p>原理:</p>
<ol>
<li>
<p>添加scoped后, 会给当前组件中所有元素, 添加上一个自定义属性</p>
<figure data-type="image" tabindex="9"><img src="https://lucas-y.github.io//post-images/1610547190490.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>添加scoped后,  每个style样式, 也会加上对应的属性选择器</p>
<figure data-type="image" tabindex="10"><img src="https://lucas-y.github.io//post-images/1610547214600.png" alt="" loading="lazy"></figure>
</li>
</ol>
<p>最终效果: 必须是当前组件的元素, 才会有这个自定义属性, 才会被这个样式作用到</p>
<h1 id="组件通信入门">组件通信入门</h1>
<p>每个组件都有自己的数据, 提供在data中, 每个组件的数据是独立的, 组件数据无法互相直接访问 (合理的)</p>
<p>但是如果需要跨组件访问数据, 就需要用到组件通信</p>
<p>组件通信的方式有很多: 现在先关注两种,  父传子  子传父</p>
<h2 id="组件通信-父传子-props-传值">组件通信 - 父传子 props 传值</h2>
<p>语法:</p>
<ol>
<li>父组件通过给子组件加属性传值</li>
</ol>
<pre><code class="language-jsx">&lt;jack price=&quot;100&quot; title=&quot;不错&quot; :info=&quot;msg&quot;&gt;&lt;/jack&gt;
</code></pre>
<ol start="2">
<li>子组件中, 通过props属性接收</li>
</ol>
<pre><code class="language-js">props: ['price', 'title', 'info']
</code></pre>
<p><strong>需求: 封装一个商品组件 my-product</strong></p>
<figure data-type="image" tabindex="11"><img src="https://lucas-y.github.io//post-images/1610547246213.png" alt="" loading="lazy"></figure>
<p><code>my-product.vue</code></p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;my-product&quot;&gt;
    &lt;h3&gt;标题: {{ title }}&lt;/h3&gt;
    &lt;p&gt;价格: {{ price }}元&lt;/p&gt;
    &lt;p&gt;{{ info }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: ['title', 'price', 'info']
}
&lt;/script&gt;

&lt;style&gt;
.my-product {
  width: 400px;
  padding: 20px;
  border: 2px solid #000;
  border-radius: 5px;
  margin: 10px;
}
&lt;/style&gt;
</code></pre>
<p><code>app.vue</code></p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;h3&gt;我是app组件的内容&lt;/h3&gt;
    &lt;my-product price=&quot;100&quot; title=&quot;超级好吃的口水鸡&quot; :info=&quot;msg&quot;&gt;&lt;/my-product&gt;
    &lt;my-product price=&quot;80&quot; title=&quot;超级难闻的榴莲&quot; :info=&quot;msg&quot;&gt;&lt;/my-product&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import MyProduct from './components/my-product.vue'
export default {
  data () {
    return {
      msg: '开业大酬宾, 全场八折'
    }
  },
  components: {
    MyProduct
  }
}
&lt;/script&gt;
</code></pre>
<h2 id="v-for-遍历展示组件练习">v-for 遍历展示组件练习</h2>
<p><strong>需求: 遍历展示商品列表</strong></p>
<p>假定, 发送请求回来的商品数据,</p>
<pre><code class="language-jsx">list: [
  { id: 1, proname: '超级好吃的棒棒糖', proprice: 18.8 },
  { id: 2, proname: '超级好吃的大鸡腿', proprice: 34.2 },
  { id: 3, proname: '超级无敌的冰激凌', proprice: 14.2 }
]
</code></pre>
<p>v-for 遍历展示</p>
<pre><code class="language-jsx">&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;h3&gt;我是app组件的内容&lt;/h3&gt;
    &lt;my-product 
      v-for=&quot;item in list&quot; :key=&quot;item.id&quot; 
      :price=&quot;item.proprice&quot; 
      :title=&quot;item.proname&quot; 
      :info=&quot;msg&quot;&gt;
    &lt;/my-product&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://lucas-y.github.io//post-images/1610547282834.png" alt="" loading="lazy"></figure>
<h2 id="区分-props-和-data">区分 props 和 data</h2>
<p>组件中的数据来源, data  props</p>
<p><strong>data 中的数据允许修改, props 中的数据不允许修改</strong>   遵循开发规范: 单向数据流</p>
<h2 id="组件通信-子传父">组件通信 - 子传父</h2>
<p><strong>需求: 砍价</strong></p>
<figure data-type="image" tabindex="13"><img src="https://lucas-y.github.io//post-images/1610547328168.png" alt="" loading="lazy"></figure>
<ol>
<li>
<p>子组件可以通过 this.$emit('事件名', 参数1, 参数2, ...) 触发事件的同时传参的</p>
<pre><code class="language-jsx">this.$emit('say-price', 2)
</code></pre>
</li>
<li>
<p>父组件给子组件注册一个自定义事件</p>
<pre><code class="language-jsx">&lt;my-product 
  ...
  @say-price=&quot;sayPrice&quot;&gt;
&lt;/my-product&gt;
</code></pre>
<p>父组件并提供对应的函数接收参数</p>
<pre><code class="language-jsx">methods: {
  sayPrice (num) {
    console.log(num)
  }
},
</code></pre>
</li>
</ol>
<hr>
<p>问题: 改价需要知道, 是改的哪个id商品的价格 ? 子组件自己都不知道自己的 id ?</p>
<p>思路:</p>
<ol>
<li>
<p>先父传子, 将 id 传递给子组件</p>
<pre><code class="language-jsx">&lt;my-product 
  v-for=&quot;item in list&quot; 
  :key=&quot;item.id&quot;
  :price=&quot;item.proprice&quot;
  :title=&quot;item.proname&quot;
  
  :id=&quot;item.id&quot;
  
  :info=&quot;msg&quot;
  @say-price=&quot;sayPrice&quot;&gt;
&lt;/my-product&gt;
</code></pre>
</li>
<li>
<p>子组件 props 接收 id</p>
<pre><code class="language-jsx">props: ['title', 'price', 'info', 'id'],
</code></pre>
</li>
<li>
<p>子传父时带上 id</p>
<pre><code class="language-jsx">this.$emit('say-price', this.id, 2)
</code></pre>
</li>
<li>
<p>父组件接收参数, 此时有两个参数了 id 和 num, 编写砍价逻辑</p>
<pre><code class="language-jsx">sayPrice (id, num) {
  // console.log(id, num)
  const item = this.list.find(item =&gt; item.id === id)
  let result = item.proprice - num
  if (result &lt;= item.lowprice) {
    result = item.lowprice
    alert('老哥最低价了:' + result + '元')
  }
  item.proprice = result.toFixed(2)
}
</code></pre>
</li>
</ol>
<h2 id="props-校验-了解">props 校验 (了解)</h2>
<p><strong>props 是父传子, 传递给子组件的数据, 为了提高 子组件被使用时 的稳定性, 可以进行props校验</strong>, 验证传递的数据是否符合要求</p>
<p>默认的数组形式, 不会进行校验, 如果希望校验, 需要提供对象形式的 props</p>
<pre><code class="language-jsx">props: {
	...
}
</code></pre>
<p>props 提供了多种数据验证方案，例如：</p>
<ul>
<li>基础的类型检查  Number</li>
<li>多个可能的类型 [String, Number]</li>
<li>必填项校验   required: true</li>
<li>默认值 default: 100</li>
<li>自定义验证函数</li>
</ul>
<p>官网语法: <a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81">地址</a></p>
<pre><code class="language-js">{
  props: {
    // 基础的类型检查
    propA: Number,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: {
      type: String,
      required: true
    },
    // 带有默认值的数字
    propD: {
      type: Number,
      default: 100
    },
    // -------------------------------------------------------------------------
    // 自定义验证函数
    propF: {
      validator: function (value) {
        // 这个值必须匹配下列字符串中的一个
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    }
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js高级]]></title>
        <id>https://lucas-y.github.io/post/js-gao-ji/</id>
        <link href="https://lucas-y.github.io/post/js-gao-ji/">
        </link>
        <updated>2021-01-12T03:41:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="暂时性死区">暂时性死区</h2>
<p><a href="https://es6.ruanyifeng.com/#docs/let">暂时性死区</a></p>
<h2 id="继承">继承</h2>
<ul>
<li>原型链继承（给原型对象添加的成员，实例对象可以继承到）</li>
</ul>
<ol>
<li>直接给原型对象添加 Person.prototype.xx = yyy;<br>
缺点：添加过多成员，以上写法重复，麻烦</li>
</ol>
<pre><code class="language-js">function Person() {}
Person.prototype.color = &quot;lime&quot;;
Person.prototype.sayHi = function () {
    console.log(&quot;hi&quot;);
}

var p = new Person();
console.log(p.color); // lime
p.sayHi();
</code></pre>
<ol start="2">
<li>原型替换  Person.prototype = {//...}<br>
缺点：造成了constructor属性丢失了<br>
解决：手动给新的原型对象补上</li>
</ol>
<pre><code class="language-js">function Person() {}
Person.prototype = {
    constructor: Person,
    sayHi: function () {
        console.log(&quot;hi&quot;);
    },
    show: function () {
        console.log(&quot;show is ok&quot;);
    },
    // ...
};
var p = new Person();
p.sayHi();
p.show();
</code></pre>
<ul>
<li>
<p>借用构造函数继承</p>
<pre><code class="language-js">  function Person(name, age, gender){
      this.name = name;
      this.age = age;
      this.gender = gender;
  }

  function China(name, age, gender, skin){
      Person.apply(this,[name,age,gender]);
      this.skin = skin;           
  }

  var xm = new China(&quot;xiaoming&quot;, 20, &quot;male&quot;, &quot;黄&quot;);
  console.log(xm);
</code></pre>
</li>
<li>
<p>组合继承<br>
<code>既可以保证每个实例都有它自己的属性，又能做到对一些属性和方法的复用</code></p>
</li>
</ul>
<pre><code class="language-js">function Person(name, age, gender){
    this.name = name;
    this.age = age;
    this.gender = gender;
}
Person.prototype.sayHi = function () {
    console.log(&quot;hello 我是&quot; + this.name);
}

function China(name, age, gender, skin){
    // 借用构造函数继承
    Person.apply(this,[name,age,gender]);
    this.skin = skin;           
}
China.prototype = new Person();
China.prototype.constructor = China;

var xm = new China(&quot;xiaoming&quot;, 20, &quot;male&quot;, &quot;黄&quot;);
xm.sayHi()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react]]></title>
        <id>https://lucas-y.github.io/post/react/</id>
        <link href="https://lucas-y.github.io/post/react/">
        </link>
        <updated>2020-12-28T00:33:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="react-是什么">react 是什么</h2>
<ul>
<li>React是一个JS库，用来构建用户界面（写HTML，构建web应用）</li>
<li>从 MVC 的角度来看，相当于 视图层 V（View） 的内容。</li>
</ul>
<h2 id="react-的特点">react 的特点</h2>
<ul>
<li>1 声明式： 我们只需要描述页面长什么样子就可以了，React负责更新页面</li>
<li>2 基于组件（组件化）</li>
<li>3 学习一次，随处使用（Web 、 安卓/ios、vr ...）</li>
</ul>
<h2 id="react-的基本使用">React 的基本使用</h2>
<ul>
<li>1 安装：npm i react react-dom</li>
<li>2 引入 react 和 react-dom 两个js文件（注意：引入顺序，react在前，react-dom 在后）</li>
<li>3 创建 React 元素
<ul>
<li><code>const h1 = React.createElement('h1', null, '子节点')</code></li>
</ul>
</li>
<li>4 渲染创建好的 React 元素，到页面中
<ul>
<li><code>ReactDOM.render(h1, document.getElementById('root'))</code></li>
</ul>
</li>
</ul>
<h2 id="reactcreateelement-方法的说明">React.createElement() 方法的说明</h2>
<ul>
<li>作用：创建react元素的</li>
</ul>
<pre><code class="language-js">// 创建React元素
// 第一个参数：表示要创建什么元素，就是 HTML 标签名称
// 第二个参数：表示元素自身属性，如果没有就传 null
//  如果要指定元素自身的属性，就传递一个对象（{}）
//  1 class ==&gt; className
//  2 for ==&gt; htmlFor
// 第三个及其以后的参数：表示元素的子节点（文本、元素节点）
//  如果是文本节点，就直接传递 字符串。
//  如果是元素节点，就继续调用 React.createElement() 方法，创建新的React元素节点
//
// const h1 = React.createElement('div', null, 'Hello React')
const h1 = React.createElement(
  'h1',
  {
    id: 'title',
    className: 'cls',
    htmlFor: 'd'
  },
  'Hello React',
  'test 文本节点',
  React.createElement('span', null, '这是一个span')
)
</code></pre>
<h2 id="react-脚手架初始化项目的步骤">React 脚手架初始化项目的步骤</h2>
<ul>
<li>命令：<code>npx create-react-app 项目名称</code>
<ul>
<li>比如：<code>npx create-react-app my-app</code></li>
</ul>
</li>
<li>npx 命令：简化使用脚手架初始化项目的流程
<ul>
<li>不使用npx：1 先全局安装脚手架的包 2 使用脚手架包提供的命令来初始化项目</li>
<li>使用 npx：不需要再全局安装脚手架的包，直接就可以初始化项目</li>
</ul>
</li>
<li>如何启动项目？进入项目根目录然后，执行以下命令
<ul>
<li>yarn start</li>
<li>npm start</li>
</ul>
</li>
</ul>
<h2 id="在脚手架中使用react">在脚手架中使用react</h2>
<ul>
<li>1 导入
<ul>
<li><code>import React from 'react'</code></li>
<li><code>import ReactDOM from 'react-dom'</code></li>
</ul>
</li>
</ul>
<h2 id="jsx">JSX</h2>
<ul>
<li>
<p>为什么要学习 JSX ？</p>
<ul>
<li>因为 createElement 形式，太繁琐，不直观，书写效率不高，所以，我们不想用这种方式。</li>
<li>JSX 特点：不反锁，直观，书写效率高</li>
</ul>
</li>
<li>
<p>JSX 是什么？ JavaScript XML（HTML），也就是在 JS 中书写 HTMl 格式的代码</p>
</li>
</ul>
<h2 id="jsx-的基本使用">JSX 的基本使用</h2>
<ul>
<li>1 导入 react 和 react-dom</li>
<li>2 使用 JSX 语法创建 React 元素
<ul>
<li>JSX 就跟写 HTML 一样</li>
</ul>
</li>
<li>3 渲染创建好的 React 元素</li>
</ul>
<h2 id="jsx-语法的注意点">JSX 语法的注意点</h2>
<ul>
<li>1 JSX元素的属性名推荐使用：驼峰命名法</li>
<li>2 class ===&gt; className</li>
<li>3 如果元素没有子节点，可以使用 单标签 方式来结束
<ul>
<li>比如：<code>&lt;div /&gt;</code></li>
</ul>
</li>
<li>4 推荐使用 () 来包裹JSX，从而避免JS中自动插入分号机制</li>
</ul>
<h2 id="在-jsx-中使用-js-表达式数据">在 JSX 中使用 JS 表达式（数据）</h2>
<ul>
<li>语法：使用 {} ，就可以在 JSX 中使用 JS 中的数据了
<ul>
<li><code>&lt;div&gt;Hello {name + '666'}&lt;/div&gt;</code></li>
</ul>
</li>
<li>原则：可以在 {} 中使用任何的 JS 表达式。</li>
<li>注意：不能在 {} 中，使用 语句！
<ul>
<li>比如： if/for/switch ...</li>
</ul>
</li>
<li>注意：不能在 {} 中使用对象，除了 style 属性以外！！！</li>
<li>JSX 自身也是一个JS表达式，所以，可以在 {} 中继续使用 JSX ！！！</li>
</ul>
<h2 id="react-的条件渲染">React 的条件渲染</h2>
<ul>
<li>1 使用if/esle来实现</li>
</ul>
<pre><code class="language-js">const loadData = () =&gt; {
  if (isLoading) {
    return &lt;div&gt;loading...&lt;/div&gt;
  }

  return &lt;div&gt;加载完成后的列表结构&lt;/div&gt;
}

const h1 = &lt;div&gt;{loadData()}&lt;/div&gt;
</code></pre>
<ul>
<li>2 使用三元表达式</li>
</ul>
<pre><code class="language-js">const loadData = () =&gt; {
  return isLoading ? &lt;div&gt;loading...&lt;/div&gt; : &lt;div&gt;加载完成后的列表结构&lt;/div&gt;
}
</code></pre>
<ul>
<li>3 逻辑运算符 &amp;&amp;</li>
</ul>
<pre><code class="language-js">const loadData = () =&gt; {
  return isLoading &amp;&amp; &lt;div&gt;loading...&lt;/div&gt;
}
</code></pre>
<h2 id="react-中的列表渲染">React 中的列表渲染</h2>
<ul>
<li>使用数组的 map 方法来进行列表渲染</li>
<li>需要给被遍历生成的元素添加 key 属性，key 应该是唯一的。尽量避免使用 index 作为索引号。</li>
<li>剩下的就是 JS 中 map 方法的使用了。</li>
</ul>
<pre><code class="language-js">&lt;ul&gt;
  {songs.map(item =&gt; (
    &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;
  ))}
&lt;/ul&gt;
</code></pre>
<h2 id="react-中给-jsx-添加样式">React 中给 JSX 添加样式</h2>
<ul>
<li>1 行内样式（style） 不推荐</li>
</ul>
<pre><code class="language-js">const h1 = (
  &lt;h1 style={{ color: 'red', fontSize: 30, backgroundColor: 'hotpink' }}&gt;
    我变大了
  &lt;/h1&gt;
)
</code></pre>
<ul>
<li>2 className 类名 --- 推荐！！！</li>
</ul>
<pre><code class="language-js">const h1 = &lt;h1 className=&quot;pink&quot;&gt;我变大了&lt;/h1&gt;
</code></pre>
<h2 id="案例">案例</h2>
<pre><code class="language-js">[
  { user: '张三', content: '哈哈，沙发' },
  { user: '张三2', content: '哈哈，板凳' },
  { user: '张三3', content: '哈哈，凉席' },
  { user: '张三4', content: '哈哈，砖头' },
  { user: '张三5', content: '哈哈，楼下山炮' }
]
</code></pre>
<h2 id="函数组件">函数组件</h2>
<ul>
<li>就是使用 JS 中的函数创建的组件，叫做函数组件。</li>
</ul>
<pre><code class="language-js">const Hello = () =&gt; &lt;div&gt;这是通过箭头函数创建的组件&lt;/div&gt;
</code></pre>
<ul>
<li>
<p>约定1：必须有返回值</p>
<ul>
<li>返回值可以为null，表示不渲染任何内容</li>
<li>如果想要渲染内容，一般就是返回 JSX</li>
</ul>
</li>
<li>
<p>约定2：组件名称必须以大写字母开头</p>
<ul>
<li>用来区分普通的 react元素 和 react组件</li>
</ul>
</li>
<li>
<p>约定3：使用函数名称作为组件的标签名称来渲染</p>
<ul>
<li><code>ReactDOM.render(&lt;Hello /&gt;, root)</code></li>
</ul>
</li>
</ul>
<h2 id="es6中的class">ES6中的class</h2>
<ul>
<li>语法：</li>
</ul>
<pre><code class="language-js">class Person {
  // 添加属性：
  constructor(age) {
    this.name = 'jack'

    this.age = age
  }

  // 添加实例方法
  say() {}
}

const p = new Person(30)
</code></pre>
<ul>
<li>继承：</li>
</ul>
<pre><code class="language-js">// 父类
class Person {
  constructor() {
    this.name = 'zhangsan'
  }
}

// 子类
class Chinese extends Person {
  constructor() {
    // 注意：手动调用super()
    // super 即 父类中的构造函数（constructor）
    super()

    // this. ....
  }
}

// 创建子类的实例对象，此时，c 就可以直接使用父类中的属性或方法了
const c = new Chinese()
// c =&gt; { name: 'zhangsan' }
</code></pre>
<h2 id="类组件">类组件</h2>
<ul>
<li>类组件：通过 ES6 中的class创建的组件，叫做 类组件</li>
<li>函数组件中的约定都适用于类组件</li>
<li>约定：类组件必须得继承自 React.Component 父类</li>
<li>约定：类组件中必须提供一个 render 方法，通过 render 方法的返回值来指定要渲染的内容</li>
</ul>
<pre><code class="language-js">// 类组件
class Hello extends React.Component {
  // render 方法是 React 中固定的一个方法名称
  render() {
    // return null
    return &lt;h1&gt;这是我的第一个 class 组件&lt;/h1&gt;
  }
}
</code></pre>
<h2 id="将组件抽离到独立的js文件中">将组件抽离到独立的JS文件中</h2>
<pre><code class="language-js">// 注意：不管是函数组件还是类组件，或者使用 JSX ，都需要导入 React！！！
import React from 'react'

// 创建 class 组件
// class Hello1 extends React.Component {
//   render() {
//     return &lt;div&gt;这是一个独立的组件&lt;/div&gt;
//   }
// }

// JSX -&gt; React.createElement()
const Hello1 = () =&gt; &lt;div&gt;这是一个独立的组件&lt;/div&gt;

// 导出组件
export default Hello1
</code></pre>
<h2 id="绑定事件">绑定事件</h2>
<ul>
<li>1 给 JSX 添加 onClick</li>
<li>2 在 {} 中，指定事件处理程序的名称（也就是一个函数名称）
<ul>
<li>注意：千万不要调用</li>
</ul>
</li>
</ul>
<pre><code class="language-js">const handleClick = () =&gt; {}

&lt;button onClick={handleClick}&gt;&lt;/button&gt;
</code></pre>
<pre><code class="language-js">// 在类组件中绑定事件
class Hello extends React.Component {
  // 事件处理程序
  handleClick() {
    console.log('你点我！')
  }

  render() {
    return &lt;button onClick={this.handleClick}&gt;点我 - class&lt;/button&gt;
  }
}
</code></pre>
<h2 id="事件对象">事件对象</h2>
<ul>
<li>如何获取到事件对象？通过事件处理程序的参数 e 来获取到</li>
<li>React 中的事件对象是一个 合成事件。</li>
<li>使用方式，与原生DOM中的使用方式相同。</li>
</ul>
<h2 id="有状态组件和无状态组件">有状态组件和无状态组件</h2>
<ul>
<li>有状态组件：class（类）组件
<ul>
<li>职责（什么时候使用）：负责更新UI（页面），也就是如果页面中的内容，需要变化</li>
<li>动</li>
</ul>
</li>
<li>无状态组件：函数组件
<ul>
<li>职责：负责展示内容</li>
<li>静</li>
</ul>
</li>
</ul>
<h2 id="class组件中的状态">class组件中的状态</h2>
<ul>
<li>状态（state）即数据</li>
<li>如何初始化状态？</li>
</ul>
<pre><code class="language-js">class Hello extends React.Component {
  constructor() {
    super()

    // 状态初始化
    this.state = {
      count: 0
    }
  }

  // 简化语法：
  // state = {
  //   count: 66
  // }

  // 在 JSX 中使用状态
  render() {
    return &lt;div&gt;计数器：{ this.state.count }&lt;/div&gt;
  }
}
</code></pre>
<h2 id="setstate">setState</h2>
<ul>
<li>作用：1 修改state 2 更新UI（页面）</li>
<li>语法：</li>
</ul>
<pre><code class="language-js">this.setState({
  count: this.state.count + 1
})
</code></pre>
<ul>
<li>注意：不要直接修改 state ！！！
<ul>
<li>错误演示：<code>this.state.count += 1</code>！！！</li>
</ul>
</li>
</ul>
<h2 id="事件处理程序中this指向问题">事件处理程序中this指向问题</h2>
<ul>
<li>1 箭头函数：</li>
</ul>
<pre><code class="language-js">// 事件处理程序中，我们要的 this 是当前组件的实例对象（它是React在渲染组件时创建）
class Hello extends React.Component {
  // 简化语法：
  state = {
    count: 0
  }

  handleClick() {
    this.setState({ ... })
  }

  render() {
    console.log('render：', this)
    return (
      &lt;div&gt;
        计数器：{this.state.count}{' '}
        &lt;button onClick={() =&gt; this.handleClick()}&gt;+1&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<ul>
<li>2 使用 bind 方法解决：</li>
</ul>
<pre><code class="language-js">constructor() {
  this.handleClick = this.handleClick.bind(this)
}

render() {
  // 此处的 handleClick 就是绑定 this 后的事件处理程序了
  return (
    &lt;button onClick={this.handleClick}&gt;&lt;/button&gt;
  )
}
</code></pre>
<ul>
<li>3 利用 class 实例方法的箭头函数形式：（推荐）</li>
</ul>
<pre><code class="language-js">class Hello extends React.Component {
  handleClick = () =&gt; {
    this.setState({ ... })
  }

  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;&lt;/button&gt;
    )
  }
}
</code></pre>
<h2 id="受控组件">受控组件</h2>
<ul>
<li>受控组件：其值收到 react 控制的表单元素，叫做受控组件</li>
</ul>
<pre><code class="language-js">state = {
  txt: ''
}

changeTxt = e =&gt; {
  this.setState({
    txt: e.target.value
  })
}

render () {
  return &lt;input type=&quot;text&quot; value={this.state.txt} onChange={this.changeTxt} /&gt;
}
</code></pre>
<h2 id="非受控组件">非受控组件</h2>
<ul>
<li>借助于 ref 就可以通过 非受控组件 的方式，来获取到的表单元素的值。</li>
<li>ref 的作用：获取DOM对象或组件。</li>
</ul>
<pre><code class="language-js">this.ref = React.createRef()

&lt;input ref={this.ref} /&gt;

文本框的值：
this.ref.current.value
</code></pre>
<h2 id="props的使用">props的使用</h2>
<ul>
<li>作用：接收到传递给组件中的属性</li>
<li>在函数组件中如何获取到 props？ 通过函数的参数</li>
<li>在 类组件 中如何获取到 props？ 通过 this.props 来获取</li>
<li>props 是一个对象！！！</li>
<li>特点：只读！！！（ 只能读取 props 对象中的属性，而不能修改 props 对象中的属性 ）</li>
<li>可以给组件传递任何类型的数据。</li>
<li>注意：如果在 class 组件中，手动添加了 constructor ，那么，就应该通过参数获取到 props， 然后传递给 super，这样，才能够在 constructor 中，获取到 props！！！</li>
</ul>
<pre><code class="language-js">const Hello = props =&gt; {
  // props 就表示传递给组件的属性
}

&lt;Hello name=&quot;jack&quot; age={19} colors={['red']} /&gt;


// 类组件：
class Hello extends React.Component {
  constructor(props) {
    super(props)

    // console.log('在构造函数中，获取到 props ', this.props)
    console.log('在构造函数中，获取到 props ', props)
  }

  render() {
    console.log('class组件中获取到props：', this.props)
    return (
      &lt;div&gt;
        &lt;h1&gt;props：{this.props.age}&lt;/h1&gt;
        {this.props.colors.map((item, index) =&gt; (
          &lt;p key={index}&gt;{item}&lt;/p&gt;
        ))}
      &lt;/div&gt;
    )
  }
}
</code></pre>
<h2 id="组件通讯">组件通讯</h2>
<h3 id="父到子">父到子</h3>
<ul>
<li>1 父组件中提供状态</li>
<li>2 在子组件标签上添加属性，值为 父组件中的状态</li>
<li>3 子组件中通过 props 来接收父组件中传递过来的数据</li>
</ul>
<pre><code class="language-js">
// 父组件：
class Parent extends React.Component {
  // 提供数据
  state = {
    lastName: '王'
  }

  render() {
    return (
      &lt;div className=&quot;parent&quot;&gt;
        &lt;h1&gt;父组件：&lt;/h1&gt;
        {/* 1 通过属性给子组件传递数据 */}
        &lt;Child name={this.state.lastName} /&gt;
      &lt;/div&gt;
    )
  }
}

// 子组件：
// 2 子组件中通过 props 接收数据
const Child = props =&gt; {
  return &lt;p className=&quot;child&quot;&gt;这是子组件：{props.name}&lt;/p&gt;
}
</code></pre>
<h3 id="子到父">子到父</h3>
<ul>
<li>
<p>思路：父组件提供一个事件（函数），让子组件调用；子组件调用的时候，将数据作为参数的传递，父组件中通过事件（函数）的参数，就拿到子组件中的数据了。</p>
</li>
<li>
<p>1 父组件提供事件</p>
</li>
<li>
<p>2 将事件通过props传递给子组件</p>
</li>
<li>
<p>3 子组件中通过props接收到父组件中传递过来的事件</p>
</li>
<li>
<p>4 子组件调用该事件，将数据作为参数传递</p>
</li>
<li>
<p>注意点：父组件提供的方法中 this 执行问题。</p>
<ul>
<li>为什么会有这个问题？因为这个方法不是父组件自己调用的，是由其他组件调用的，所以，需要处理this指向。</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 1 提供事件（回调函数，）
//  事件是子组件调用的，因此，先要通过 props 传递给子组件
// 2 将事件传递给子组件
class Parent extends React.Component {
  state = {
    msg: ''
  }

  getChildMsg = data =&gt; {
    console.log('父组件中的方法调用了', data)
    this.setState({
      msg: data
    })
  }

  // 注意：this指向问题，因为这个方法是由子组件调用的，所以，应该提前处理好 this 指向！
  /* getChildMsg(data) {
    console.log('父组件中的方法调用了', data, this)
    this.setState({
      msg: data
    })
  } */

  render() {
    return (
      &lt;div className=&quot;parent&quot;&gt;
        &lt;h1&gt;父组件：{this.state.msg}&lt;/h1&gt;
        &lt;Child fn={this.getChildMsg} /&gt;
      &lt;/div&gt;
    )
  }
}

// 子组件：
// 3 子组件中通过 props 接收到父组件中传递过来的事件
// 4 子组件中调用传递过来的事件， 将数据作为事件的参数传递
const Child = props =&gt; {
  // console.log(props)
  const handleClick = () =&gt; {
    // 调用
    props.fn('撩汉子')
  }

  return (
    &lt;p className=&quot;child&quot;&gt;
      这是子组件：
      &lt;button onClick={handleClick}&gt;发送数据给父组件&lt;/button&gt;
    &lt;/p&gt;
  )
}
</code></pre>
<h3 id="兄弟组件">兄弟组件</h3>
<ul>
<li>思路：<strong>状态提升</strong>，也就是：将两个兄弟组件之间的共享数据，放在父组件中。</li>
<li>父组件的职责：1 提供共享数据（state） 2 提供修改状态的方法</li>
<li>例子：如果 子组件2 要传递数据给 子组件1</li>
<li>子组件1：只要通过 props 接收到父组件中传递过来的数据（父 -&gt; 子）</li>
<li>子组件2：调用父组件中修改状态的方法（子 -&gt; 父）
<ul>
<li>但是，需要先通过 props 获取到父组件中传递过来的方法</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 父组件
// 1 提供状态
// 2 提供操作状态的方法
class Parent extends React.Component {
  state = {
    msg: '默认值'
  }

  updateMsg = data =&gt; {
    this.setState({
      msg: data
    })
  }

  render() {
    return (
      &lt;div className=&quot;parent&quot;&gt;
        这是父组件：
        &lt;Child1 msg={this.state.msg} /&gt;
        &lt;Child2 updateMsg={this.updateMsg} /&gt;
      &lt;/div&gt;
    )
  }
}

// 子组件1
// 3 接收数据（数据由父组件提供）
class Child1 extends React.Component {
  render() {
    return &lt;div className=&quot;child&quot;&gt;这是子组件1：{this.props.msg}&lt;/div&gt;
  }
}

// 子组件2：
// 4 在父组件中传递事件给子组件
// 5 给按钮绑定单击事件
// 6 调用父组件中的事件来更新数据
class Child2 extends React.Component {
  // 单击事件
  handleClick = () =&gt; {
    // 调用父组件的事件
    this.props.updateMsg('子组件2222222222222222222222')
  }

  render() {
    return (
      &lt;div className=&quot;child2&quot;&gt;
        这是子组件2：
        &lt;button onClick={this.handleClick}&gt;传递数据给 Child1&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<h2 id="评论列表案例">评论列表案例</h2>
<ul>
<li>
<p>分析：因为 CommentList 和 CommentForm 这两个子组件中，都要用到 评论列表 数据，所以，就利用 状态提升 的思想，将评论列表数据放在了 父组件Comment 中。</p>
<ul>
<li>父组件的两个职责：1 提供评论列表数据状态（list） 2 提供修改状态的方法（updateComment）</li>
</ul>
</li>
<li>
<p>功能1：渲染评论列表</p>
<ul>
<li>利用 父-&gt;子 的通讯，将父组件中的 list 传递给 子组件；子组件中通过 props 接收</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 父组件中渲染子组件：
&lt;CommentList list={this.state.list} /&gt;

// 子组件中：
&lt;ul&gt;
  {props.list.map(item =&gt; (
    &lt;li key={item.id}&gt;
      &lt;h3&gt;评论人：{item.name}&lt;/h3&gt;
      &lt;p&gt;评论内容：{item.content}&lt;/p&gt;
    &lt;/li&gt;
  ))}
&lt;/ul&gt;
</code></pre>
<ul>
<li>功能2：添加评论
<ul>
<li>a. 通过受控组件的方式，来获取到评论人和评论内容</li>
<li>b. 将用户输入的内容，添加到 list 中
<ul>
<li>因为 list 是由父组件提供的，所以，由父组件提供修改状态的方法（updateComment）；通过 props 传递给子组件后，由子组件调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 父组件中渲染子组件：
&lt;CommentForm updateComment={this.updateComment} /&gt;

// 子组件中：
// 发表评论
addComment = () =&gt; {
  const { name, content } = this.state
  // ...

  this.props.updateComment(name, content)

  // ...
}
</code></pre>
<h2 id="context">Context</h2>
<ul>
<li>使用场景：跨组件传递数据</li>
</ul>
<ol>
<li>如果两个组件是远方亲戚（比如，嵌套多层）可以使用Context实现组件通讯</li>
<li>Context提供了两个组件：Provider 和 Consumer</li>
<li>Provider组件：用来提供数据</li>
<li>Consumer组件：用来消费数据</li>
</ol>
<pre><code class="language-js">const { Provider, Consumer } = React.createContext()

&lt;Provider value={this.state.msg}&gt;
  &lt;div className=&quot;parent&quot;&gt;
    这是父组件：
    &lt;Child1 /&gt;
  &lt;/div&gt;
&lt;/Provider&gt;

// Child1 -&gt; Child2 -&gt; Child3

// Child3
// data 就是 Provider 中提供的 value
&lt;Consumer&gt;{data =&gt; &lt;p&gt;接收到的数据为：{data}&lt;/p&gt;}&lt;/Consumer&gt;
</code></pre>
<h2 id="组件的-children-属性">组件的 children 属性</h2>
<ul>
<li>作用：获取组件标签的子节点</li>
<li>获取方式： props.children</li>
<li>children 与普通的 props 属性相同，可以是任意值。</li>
</ul>
<pre><code class="language-js">&lt;Hello&gt;
  我是子节点 -&gt; 这就是 children 属性的内容。
&lt;/Hello&gt;
</code></pre>
<h2 id="props-校验">props 校验</h2>
<ul>
<li>
<p>场景：给组件添加 props 校验，来增强组件的健壮性。</p>
<ul>
<li>约定：封装公共组件的时候，都添加 props 校验</li>
</ul>
</li>
<li>
<p>1 安装：<code>yarn add prop-types</code></p>
</li>
<li>
<p>2 导入 <code>import PropTypes from 'prop-types'</code></p>
</li>
<li>
<p>3 给组件名称添加 <code>propTypes</code> 属性，值是一个对象</p>
</li>
<li>
<p>4 对象的键就是要校验的 props 名称，值是 <code>PropTypes.array</code> 等，从PropTypes中获取到的校验规则</p>
</li>
</ul>
<pre><code class="language-js">const Parent = () =&gt; { ... }

// 2 给组件添加 props 校验
Parent.propTypes = {
  // 规定 colors 属性的类型为：数组（array），如果将来使用组件的时候，传入的 colors 属性类型不是 array ，就会通过警告来告诉使用者。
  colors: PropTypes.array,

  gender: PropTypes.oneOf(['male', 'female']).isRequired
}
</code></pre>
<h2 id="props-默认值">props 默认值</h2>
<ul>
<li>可以通过 组件名.defaultProps = {} 来给组件添加 props 的默认值。</li>
</ul>
<pre><code class="language-js">const Parent = () =&gt; { ... }

// 添加 props 的默认值：
Parent.defaultProps = {
  gender: 'male'
}
</code></pre>
<h2 id="class组件生命周期">class组件生命周期</h2>
<ul>
<li>注意：只有 class 组件才会有生命周期</li>
<li><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">生命周期文档</a></li>
</ul>
<h3 id="1-挂载阶段">1 挂载阶段</h3>
<ul>
<li>1 constructor</li>
<li>2 render</li>
<li>3 <strong>componentDidMount</strong>
<ul>
<li>3.1 发送ajax请求</li>
<li>3.2 操作DOM</li>
</ul>
</li>
</ul>
<pre><code class="language-js">class Hello extends React.Component {
  // 最早执行：
  // 1 初始化state
  // 2 给事件处理程序绑定 this
  constructor(props) {
    super(props)

    console.warn('1 组件生命周期钩子函数： constructor')
  }

  // 作用1：可以用来在进入页面时（该组件渲染时），发送ajax请求
  // 作用2：可以操作DOM（因为 render 已经将 JSX 渲染到页面中了）
  componentDidMount() {
    console.warn(
      '3 组件生命周期钩子函数： componentDidMount',
      (document.getElementsByTagName('h1')[0].style.color = 'red')
    )
  }

  // 作用：渲染 UI，负责将 JSX 渲染到页面中
  // 注意：不要在 render 方法中调用 setState() 方法，否则，会造成死循环！
  render() {
    // this.setState({})
    console.warn('2 组件生命周期钩子函数： render')
    return (
      &lt;div&gt;
        &lt;h1&gt;class 组件&lt;/h1&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<h3 id="2-更新阶段">2 更新阶段</h3>
<ul>
<li>
<p>1 render（ 同挂载阶段的render ）</p>
</li>
<li>
<p>2 componentDidUpdate（ 知道 ）</p>
</li>
<li>
<p>导致组件更新的三种情况：</p>
<ul>
<li>1 setState()</li>
<li>2 组件接收到新的props</li>
<li>3 forceUpdate()</li>
</ul>
</li>
<li>
<p>注意：不管是 函数组件 还是 类组件，只要接收到新的 props ，那么，组件都会重新渲染</p>
</li>
</ul>
<pre><code class="language-js">class Hello extends React.Component {
  state = {
    count: 0
  }

  // 第一个参数：表示上一次的 props
  // 第二个参数：表示上一次的 state
  // 说明：可以在该钩子函数中调用 setState()，但是，一定要把 setState() 放在一个条件判断中
  //      比如：可以对比更新前后的 props 是否相同，或者 对比更新前后的 状态是否相同
  // 注意：不要直接调用 setState() 否则，会造成死循环
  componentDidUpdate(prevProps, prevState) {
    console.warn(
      '2 组件生命周期钩子函数： componentDidUpdate',
      document.getElementsByTagName('h1')[0].innerText,
      prevProps,
      prevState
    )

    // 如何获取最新的props 和 最新的state？
    console.log(this.props, this.state)
  }

  handleClick = () =&gt; {
    this.setState({
      count: this.state.count + 1
    })

    // 强制组件更新（知道即可）：
    // forceUpdate()
    // this.forceUpdate()
  }

  render() {
    console.warn('1 组件生命周期钩子函数： render')
    return (
      &lt;div&gt;
        &lt;Child count={this.state.count} /&gt;
        &lt;button onClick={this.handleClick}&gt;更新组件&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}

// 当组件接收到新的 props 值时，也会触发组件更新
class Child extends React.Component {
  componentDidUpdate() {
    console.warn('子组件 -&gt; 的生命周期钩子函数： componentDidUpdate')
  }

  render() {
    console.warn('子组件 -&gt; 的生命周期钩子函数： render')
    return &lt;h1&gt;计数器：{this.props.count}&lt;/h1&gt;
  }
}
</code></pre>
<h3 id="3-卸载阶段">3 卸载阶段</h3>
<ul>
<li>触发时机：组件卸载，也就是从页面中消失的时候</li>
<li>componentWillUnmount
<ul>
<li>作用：执行清理工作，比如：清理定时器、给window绑定的事件等，我们手动开启的操作</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 当组件从页面中消失，此时，就会触发组件的卸载阶段
class Child extends React.Component {
  componentDidMount() {
    // 开启定时器
    // this.timerId = setInterval(() =&gt; {
    //   console.log('定时器触发了')
    // }, 1000)

    window.addEventListener('resize', this.handleResize)
  }

  handleResize = () =&gt; {
    console.log('窗口大小改变了')
  }

  // 组件将要卸载
  componentWillUnmount() {
    console.warn('组件生命周期钩子函数： componentWillUnmount')

    // 清理定时器
    // clearInterval(this.timerId)
    window.removeEventListener('resize', this.handleResize)
  }

  render() {
    return &lt;h1&gt;统计豆豆被打的次数：{this.props.count}&lt;/h1&gt;
  }
}
</code></pre>
<h2 id="render-props-模式的使用">render-props 模式的使用</h2>
<ul>
<li>
<p>作用：实现<strong>状态逻辑复用</strong></p>
</li>
<li>
<p>Mouse 组件的职责：</p>
<ul>
<li>1 提供了state</li>
<li>2 提供了操作状态的方法</li>
</ul>
</li>
<li>
<p>注意：Mouse 组件仅仅负责状态逻辑复用，不会指定要渲染的内容。</p>
</li>
<li>
<p>要渲染什么内容，就在复用 Mouse 组件的时候，通过 render 属性的返回值指定</p>
</li>
</ul>
<pre><code class="language-js">// 复用Mouse组件，渲染p标签：
&lt;Mouse render={mouse =&gt; &lt;p&gt;&lt;/p&gt;} /&gt;

// 复用Mouse组件，渲染img标签：
&lt;Mouse render={mouse =&gt; &lt;img src=... /&gt;} /&gt;
</code></pre>
<ul>
<li>但是，render 属性的返回值要生效，必须得在 Mouse 组件中，来处理才可以</li>
</ul>
<pre><code class="language-js">class Mouse extends React.Component {
  // ...

  render() {
    // 调用 render 这个属性，通过它的返回值，来拿到要渲染的内容
    return this.props.render(this.state)
  }
}
</code></pre>
<ul>
<li>推荐：使用 children 代替 render 属性</li>
</ul>
<pre><code class="language-js">&lt;Mouse&gt;
  {
    mouse =&gt; &lt;p&gt;{mouse.x} - {mouse.y}&lt;/p&gt;
  }
&lt;/Mouse&gt;

// 组件中：
render() {
  return this.props.children(this.state)
}
</code></pre>
<h2 id="高阶组件">高阶组件</h2>
<ul>
<li>作用：实现<strong>状态逻辑复用</strong></li>
<li>使用包装模式，也就是：使用一个组件（A）来包装另外一个组件，这样，另外一个组件中，就可以通过 props 来拿到组件A提供的状态</li>
<li>高阶组件实际上是一个函数，比如：<code>withMouse</code></li>
</ul>
<pre><code class="language-js">// 参数Cat：就是被包装的组件
// 返回值CatWithMouse：就是增强后的组件。处理后，CatWithMouse中既有结构又有鼠标位置了
const CatWithMouse = withMouse(Cat)

const withMouse = (WrappedComponent) =&gt; {
  class Mouse extends React.Component {
    // 实现状态 和 操作状态的方法

    render() {
      return &lt;WrappedComponent {...this.state} {...this.props} /&gt;
    }
  }

  return Mouse
}

&lt;CatWithMouse name=&quot;jack&quot; /&gt;
</code></pre>
<h2 id="简化受控组件的使用">简化受控组件的使用</h2>
<ul>
<li>1 在 state 中添加表单元素的状态</li>
<li>2 将 state 设置为每个表单元素的 value 值</li>
<li>3 给 表单元素 绑定 change 事件</li>
<li>4 创建 handleChange 事件处理程序，用来统一处理表单项的值</li>
<li>5 <strong>给每一个表单元素添加 name 属性，name 属性的值为：当前对应的状态名称</strong></li>
<li>6 在 handleChange 这个统一的事件处理程序中，通过 e.target.name 来获取到当前要更新的状态名称</li>
<li>7 使用 ES6 中的属性名表达式，来更新状态即可</li>
<li>注意：因为 checkbox 复选框，操作的是 checked 属性（也就是是否选中），所以，需要对 checkbox 进行特殊的处理。</li>
</ul>
<pre><code class="language-js">import React from 'react'

export default class CommentForm extends React.Component {
  // 1 提供状态
  state = {
    // 评论人
    name: '',
    // 评论内容：
    content: '',
    // city
    city: ''
  }
  
  handleChange = e =&gt; {
    const target = e.target
    // 针对于表单元素进行处理：
    const value = target.type === 'checkbox' ? target.checked : target.value

    // name 就是要更新的状态名称
    const name = target.name

    // http://es6.ruanyifeng.com/#docs/object#%E5%B1%9E%E6%80%A7%E5%90%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F
    this.setState({
      [name]: value
    })
  }

  // 发表评论：
  addComment = () =&gt; {
    const { name, content, city } = this.state
    console.log(name, content, city)
  }

  render() {
    const { name, content, city } = this.state

    return (
      &lt;div&gt;
        {/* 给每一个表单项添加 name 属性，值为：当前表单项对应的状态 */}
        &lt;input
          type=&quot;text&quot;
          placeholder=&quot;评论人&quot;
          value={name}
          name=&quot;name&quot;
          onChange={this.handleChange}
        /&gt;
        &lt;br /&gt;
        &lt;textarea
          cols=&quot;30&quot;
          rows=&quot;10&quot;
          placeholder=&quot;评论内容&quot;
          value={content}
          name=&quot;content&quot;
          onChange={this.handleChange}
        /&gt;
        &lt;br /&gt;
        &lt;select name=&quot;city&quot; value={city} onChange={this.handleChange}&gt;
          &lt;option value=&quot;1&quot;&gt;北京&lt;/option&gt;
          &lt;option value=&quot;2&quot;&gt;上海&lt;/option&gt;
          &lt;option value=&quot;3&quot;&gt;航头&lt;/option&gt;
        &lt;/select&gt;
        &lt;br /&gt;
        &lt;input
          type=&quot;checkbox&quot;
          name=&quot;isChecked&quot;
          checked={isChecked}
          onChange={this.handleChange}
        /&gt;
        &lt;button onClick={this.addComment}&gt;发表评论&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<h2 id="setstate-的说明">setState 的说明</h2>
<ul>
<li>
<p>注意：<code>setState({})</code> 方法是异步更新数据的！如果同时调用 setState() 方法多次，后面的 setState() 不要依赖于前面的 setState() 结果。</p>
</li>
<li>
<p>不管同时调用多少次 setState()，都只会触发一次重新渲染</p>
</li>
<li>
<p>推荐使用：<code>setState((state, props) =&gt; {})</code></p>
<ul>
<li>通过该语法形式，就可以做到：后面的setState()可以依赖于上面setState()的值</li>
</ul>
</li>
<li>
<p>setState() 方法由两个参数：</p>
<ul>
<li>1 第一个参数用来更新状态</li>
<li>2 第二个参数是一个回调函数，表示组件状态更新后，立即出发的操作（知道）</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 修改状态：
// setState() 是异步更新数据的
handleClick = () =&gt; {
  console.log('setState前的状态：', this.state.count)

  // 回调函数的参数：
  // 1 state 表示最新的状态
  // 2 props 表示最新的 props
  // 通过回调函数的返回值，来更新状态
  this.setState((state, props) =&gt; {
    return {
      count: state.count + 2
    }
  }, () =&gt; {})

  console.log('setState后的状态：', this.state.count)
}
</code></pre>
<h2 id="jsx-语法的转化过程">JSX 语法的转化过程</h2>
<ul>
<li>JSX -&gt; React.createElement() -&gt; JS对象（用来告诉 React 最终要渲染在页面中的内容）</li>
</ul>
<h2 id="react-组件更新机制">React 组件更新机制</h2>
<ul>
<li>特点：只要父组件更新了，那么，父组件自己以及它的所有子组件（后代组件），全部会被更新。</li>
</ul>
<h2 id="组件性能优化">组件性能优化</h2>
<h3 id="1-减轻state">1 减轻state</h3>
<ul>
<li>只把更组件渲染内容相关的数据放在 state 中
<ul>
<li>1 count（计数器）</li>
<li>2 list（评论列表数据）</li>
<li>3 loading（是否加载中，它会控制组件要渲染的内容）</li>
</ul>
</li>
<li>注意：不要把跟组件渲染无关的数据，放在 state 中，而把这些数据直接放在 this 中即可</li>
</ul>
<h3 id="2-shouldcomponentupdate">2 shouldComponentUpdate</h3>
<ul>
<li>
<p>使用场景：阻止不必要的更新</p>
</li>
<li>
<p>作用：通过返回值来决定是否重新渲染组件</p>
<ul>
<li>如果返回true，就会更新组件；</li>
<li>如果返回false，就不会更新组件</li>
</ul>
</li>
<li>
<p>参数表示最新的 props 和 state</p>
</li>
<li>
<p>可以通过 this.props 和 this.state 来获取到上一次（更新前的）的值</p>
</li>
</ul>
<pre><code class="language-js">// 第一个参数：表示最新的props值
// 第二个参数：表示最新的state值
shouldComponentUpdate(nextProps, nextState) {
  if (nextProps.count % 2 === 0) {
    // 此时为 偶数
    return false
  }
  return true
}
</code></pre>
<h3 id="3-使用纯组件">3 使用纯组件</h3>
<ul>
<li>用法：只要将 React.Component 替换为 React.PureComponent 即可</li>
<li>原理：内部会自动实现 shouldComponentUpdate 钩子函数，会分别对比 更新前后的 props 和 state，只要有一个发生变化了，就会更新组件；换句话说，也就是：如果 props 或 state，都没有改变，此时，组件就不会更新了。</li>
</ul>
<pre><code class="language-js">class Child2 extends React.PureComponent {
  render() {
    console.log('Child2 组件重新渲染了')
    return &lt;h1&gt;随机数：{this.props.number}&lt;/h1&gt;
  }
}
</code></pre>
<h3 id="纯组件内部的原理">纯组件内部的原理</h3>
<ul>
<li>原理：内部进行的是浅对比（shallow compare）</li>
<li>对于值类型，直接修改即可，没有坑</li>
<li>但是，对于引用类型来说：（只比较对象的地址）
<ul>
<li>1 如果直接修改当前对象中属性的值，那么，在更新状态的时候，即便数据变化了，组件也不会被重新渲染</li>
<li>2 应该创建新的引用类型值，再更新状态</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// 1 不要这么做：
// 在 PureComponent 中，不会让组件重新渲染
const { obj } = this.state
const newObj = obj
newObj.number = number

this.setState({
  obj: newObj
})
</code></pre>
<pre><code class="language-js">// 2 正确做法：
const { obj } = this.state
// 注意：此处创建了一个新的对象 newObj
const newObj = { ...obj }
newObj.number = number

this.setState({
  obj: newObj
})
</code></pre>
<h2 id="更新组件的原则">更新组件的原则</h2>
<ul>
<li><strong>不要直接修改当前状态的值（引用类型），而是创建一个新的对象或数组</strong></li>
</ul>
<pre><code class="language-js">// 推荐修改数组值的方式：
this.setState({
  list: [...this.state.list, { ..省略对象结构 }]
})
// ES5：
// const newList = list.concat([ ... ])

// 推荐修改对象值的方式：
this.setState({
  obj: {...this.state.obj, number: ...}
})
// ES5：
// Object.assign(目标对象, 原来的状态对象, 新的状态对象)
// 当前例子中：const newObj = Object.assign({}, this.state.obj, { number: 9 })
</code></pre>
<h2 id="虚拟dom-和-diff算法">虚拟DOM 和 Diff算法</h2>
<ul>
<li>
<p>React 中一个组件的更新方式：只要调用 setState() 当前这个组件就会被更新。也就是会调用 render() 方法。</p>
<ul>
<li>但是：不是 render() 方法被调用，整个组件的内容，就会被全部更新！！！</li>
</ul>
</li>
<li>
<p>实际上，React 内部会实现：<strong>部分更新</strong>，也就是，哪个地方需要更新，只会把这个地方对应的DOM重新渲染</p>
</li>
</ul>
<h3 id="diff-算法的说明-1">Diff 算法的说明 - 1</h3>
<ul>
<li>如果两棵树的根元素类型不同，React 会销毁旧树，创建新树</li>
</ul>
<pre><code class="language-js">// 旧树
&lt;div&gt;
  &lt;Counter /&gt;
&lt;/div&gt;

// 新树
&lt;span&gt;
  &lt;Counter /&gt;
&lt;/span&gt;

执行过程：destory Counter -&gt; insert Counter
</code></pre>
<h3 id="diff-算法的说明-2">Diff 算法的说明 - 2</h3>
<ul>
<li>对于类型相同的 React DOM 元素，React 会对比两者的属性是否相同，只更新不同的属性</li>
<li>当处理完这个 DOM 节点，React 就会递归处理子节点。</li>
</ul>
<pre><code class="language-html">// 旧
&lt;div className=&quot;before&quot; title=&quot;stuff&quot;&gt;&lt;/div&gt;
// 新
&lt;div className=&quot;after&quot; title=&quot;stuff&quot;&gt;&lt;/div&gt;
只更新：className 属性

// 旧
&lt;div style={{color: 'red', fontWeight: 'bold'}}&gt;&lt;/div&gt;
// 新
&lt;div style={{color: 'green', fontWeight: 'bold'}}&gt;&lt;/div&gt;
只更新：color属性
</code></pre>
<h3 id="diff-算法的说明-3">Diff 算法的说明 - 3</h3>
<ul>
<li>1 当在子节点的后面添加一个节点，这时候两棵树的转化工作执行的很好</li>
</ul>
<pre><code class="language-js">// 旧
&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;

// 新
&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
  &lt;li&gt;third&lt;/li&gt;
&lt;/ul&gt;

执行过程：
React会匹配新旧两个&lt;li&gt;first&lt;/li&gt;，匹配两个&lt;li&gt;second&lt;/li&gt;，然后添加 &lt;li&gt;third&lt;/li&gt; tree
</code></pre>
<ul>
<li>2 但是如果你在开始位置插入一个元素，那么问题就来了：</li>
</ul>
<pre><code class="language-js">// 旧
&lt;ul&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
&lt;/ul&gt;

// 新
&lt;ul&gt;
  &lt;li&gt;3&lt;/li&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
&lt;/ul&gt;

执行过程：
React将改变每一个子节点，而非保持 &lt;li&gt;Duke&lt;/li&gt; 和 &lt;li&gt;Villanova&lt;/li&gt; 不变
</code></pre>
<h3 id="key-属性">key 属性</h3>
<blockquote>
<p>为了解决以上问题，React 提供了一个 key 属性。当子节点带有 key 属性，React 会通过 key 来匹配原始树和后来的树。</p>
</blockquote>
<pre><code class="language-js">// 旧
&lt;ul&gt;
  &lt;li key=&quot;2015&quot;&gt;1&lt;/li&gt;
  &lt;li key=&quot;2016&quot;&gt;2&lt;/li&gt;
&lt;/ul&gt;

// 新
&lt;ul&gt;
  &lt;li key=&quot;2014&quot;&gt;3&lt;/li&gt;
  &lt;li key=&quot;2015&quot;&gt;1&lt;/li&gt;
  &lt;li key=&quot;2016&quot;&gt;2&lt;/li&gt;
&lt;/ul&gt;

执行过程：
现在 React 知道带有key '2014' 的元素是新的，对于 '2015' 和 '2016' 仅仅移动位置即可
</code></pre>
<ul>
<li>说明：key 属性在 React 内部使用，但不会传递给你的组件</li>
<li>推荐：在遍历数据时，推荐在组件中使用 key 属性：<code>&lt;li key={item.id}&gt;{item.name}&lt;/li&gt;</code></li>
<li>注意：<strong>key 只需要保持与他的兄弟节点唯一即可，不需要全局唯一</strong></li>
<li>注意：<strong>尽可能的减少数组 index 作为 key，数组中插入元素的等操作时，会使得效率底下</strong></li>
</ul>
<h2 id="组件的极简模型">组件的极简模型</h2>
<ul>
<li><code>(state, props) =&gt; UI</code></li>
</ul>
<h2 id="路由的基本使用">路由的基本使用</h2>
<ul>
<li>React路由中的一切都是组件，所以，如何使用 React的组件，就如何使用 React路由。</li>
<li>1 安装：<code>yarn add react-router-dom</code></li>
<li>2 导入路由中的三个组件：<code>Router</code> / <code>Route</code> / <code>Link</code></li>
<li>3 使用 Router 组件包裹整个应用</li>
<li>4 使用 Link 组件配置路由的入口
<ul>
<li>通过 to 属性来指定 pathname（也就是浏览器地址栏中的地址）</li>
</ul>
</li>
<li>5 使用 Route 组件配置路由出口
<ul>
<li>path 属性：指定路由规则</li>
<li>component 属性：指定该路由规则匹配时要展示的组件</li>
</ul>
</li>
</ul>
<pre><code class="language-js">import { BrowserRouter as Router, Route, Link } from 'react-router-dom'

// 创建First组件
const First = () =&gt; &lt;p&gt;这是 First 组件的内容&lt;/p&gt;
const Home = () =&gt; &lt;div style={{ color: 'red' }}&gt;这是 Home 组件&lt;/div&gt;

class App extends React.Component {
  render() {
    return (
      // 3 使用 Router 组件包裹整个应用
      &lt;Router&gt;
        &lt;div&gt;
          &lt;h1&gt;使用 react 路由&lt;/h1&gt;
          {/* 4 配置路由的入口（也就是一个导航菜单） */}
          &lt;Link to=&quot;/first&quot;&gt;页面一&lt;/Link&gt;
          &lt;br /&gt;
          &lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;

          {/* 5 配置路由的出口（配置路由规则和要展示的组件） */}
          &lt;Route path=&quot;/first&quot; component={First} /&gt;

          {/* 再创建另一外一个路由： */}
          &lt;Route path=&quot;/home&quot; component={Home} /&gt;
        &lt;/div&gt;
      &lt;/Router&gt;
    )
  }
}
</code></pre>
<h2 id="react-路由使用的说明">React 路由使用的说明</h2>
<ul>
<li>Router 组件：整个应用使用<strong>一次</strong>即可！也就是用 Router 包裹整个应用</li>
<li>React 路由有两种模式：
<ul>
<li>1 使用哈希值实现（hash）： HashRouter</li>
<li>2 使用 H5 中的 history API： BrowserRouter（推荐）</li>
</ul>
</li>
<li>Link 组件：用来设置导航菜单
<ul>
<li>这个组件最终会被渲染成一个 a 标签</li>
<li>to 属性：用来指定浏览器地址栏中的 哈希值 或者 pathname</li>
</ul>
</li>
<li>Route 组件：用来设置路由规则
<ul>
<li>path 属性：配置路由规则</li>
<li>component 属性：指定要展示的组件</li>
</ul>
</li>
</ul>
<pre><code class="language-js">// H5 中的 history API
import { BrowserRouter as Router, Route, Link } from 'react-router-dom'

// 使用 哈希值（浏览器地址栏中的 #/） 来实现路由：
import { HashRouter as Router, Route, Link } from 'react-router-dom'
</code></pre>
<h2 id="编程式导航">编程式导航</h2>
<ul>
<li>
<p>编程式导航：可以通过 JS 代码的方式，来实现路由跳转</p>
</li>
<li>
<p>组件中通过 <code>props</code> 来获取到路由信息</p>
<ul>
<li>对于函数组件来说就是通过 参数props 来获取</li>
<li>对于类组件来说，就是通过 this.props 来获取</li>
</ul>
</li>
<li>
<p><code>push(path)</code>：跳转到参数中指定的路由地址</p>
</li>
<li>
<p><code>go(n)</code>：前进（1）或后退（-1）</p>
</li>
</ul>
<pre><code class="language-js">const First = props =&gt; {
  const handleClick = () =&gt; {
    // push 方法用来实现路由的跳转
    // 参数：表示要跳转到的路由的路径
    props.history.push('/login')
  }

  return (
    &lt;p&gt;
      这是 First 组件的内容
      &lt;button onClick={handleClick}&gt;跳转到登录页面&lt;/button&gt;
    &lt;/p&gt;
  )
}
</code></pre>
<h2 id="默认路由">默认路由</h2>
<ul>
<li>默认路由地址为：<code>/</code></li>
<li>默认路由，在进入页面时，就会被匹配</li>
</ul>
<pre><code class="language-js">const Home = () =&gt; &lt;p&gt;这是首页，进入页面时，就会展示该组件内容&lt;/p&gt;
&lt;Route path=&quot;/&quot; component={Home} /&gt;
</code></pre>
<h2 id="路由匹配规则">路由匹配规则</h2>
<ul>
<li>默认情况下，路由是<strong>模糊匹配</strong>的</li>
<li>也就是说：只要 pathname 是以 path 开头，那么， 这个路由规则就会匹配成功
<ul>
<li>比如：pathname 是 '/first'，path 是 '/'，此时，pathname 是以 / 开头的，所以，此时，这个路由规则就被匹配了，也就是 会展示该规则对应的组件</li>
</ul>
</li>
</ul>
<pre><code class="language-js">&lt;Route path=&quot;/&quot; component={Home} /&gt;
</code></pre>
<h2 id="精确匹配">精确匹配</h2>
<ul>
<li>给 Route 添加 <code>exact</code> 属性，就会让当前路由规则变为精确匹配</li>
<li>此时，只有当 pathname 和 path 完全匹配时，才会展示该组件。</li>
</ul>
<pre><code class="language-js">// 精确匹配：
// pathname 是 '/first'，path 是 '/'，此时，就不会匹配了
// 只有当 pathname 是 '/' 并且 path 也是 '/' ，此时才会匹配
&lt;Route exact path=&quot;/&quot; component={Home} /&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue基础]]></title>
        <id>https://lucas-y.github.io/post/vue/</id>
        <link href="https://lucas-y.github.io/post/vue/">
        </link>
        <updated>2020-12-25T02:14:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="vue-的基本概念">vue 的基本概念</h2>
<p><a href="https://cn.vuejs.org/">vue官网</a><br>
<code>vue是一个渐进式的 javascript 框架</code></p>
<ul>
<li>渐进式  =&gt;  逐渐增强, 学一点用一点, 利于上手</li>
<li>框架:  一套完整的解决方案</li>
</ul>
<blockquote>
<p><strong>特点</strong>: 需要按照框架的规则编写代码   <strong>好处</strong>: 大大的提升了开发效率</p>
</blockquote>
<h2 id="vue3-和-vue2的区别">vue3 和 vue2的区别</h2>
<h3 id="版本说明">版本说明</h3>
<p>当前，vue 共有 3 个大版本，其中：</p>
<ul>
<li><strong><code>2.x 版本</code>的 vue 是目前企业级项目开发中的主流版本</strong></li>
<li><code>3.x 版本</code>的 vue 于 2020-09-19 正式发布，生态还不完善，尚未在企业级项目开发中普及和推广</li>
<li><code>1.x 版本</code>的 vue 几乎被淘汰，不再建议学习与使用<br>
总结:</li>
</ul>
<ol>
<li>目前进公司,  公司一定选稳定的开发模式!  主流版本一定是 vue2 (<strong>必须重点掌握</strong>)</li>
<li>vue3 虽然生态尚不完善, 没有那么普及, 但是我们可以 <strong>前瞻变化</strong> , 这是将来的趋势</li>
</ol>
<h3 id="vue3-和-vue2-的对比">vue3 和 vue2 的对比</h3>
<p>vue2.x 中绝大多数的 API 与特性，在 vue3.x 中同样支持。 (<strong>向前兼容</strong>)<br>
同时，vue3.x 中还新增了 3.x 所特有的功能, 废弃了一些旧功能</p>
<ol>
<li>新增例如：<strong><code>组合式 API (函数式编程)</code></strong>、多根节点组件、更好的 TypeScript 支持等  (ts 在原生基础上, 增加了类型检测)</li>
<li>废弃例如：<strong><code>过滤器</code></strong> 等<br>
如果是2.x的版本, 可以放心的使用过滤器<br>
如果项目已经升级到了3.x 版本的 vue，官方建议使用计算属性或方法代替被剔除的过滤器功能<br>
官方迁移指南: https://v3.vuejs.org/guide/migration/introduction.html</li>
</ol>
<h2 id="mvvm设计模式">MVVM设计模式</h2>
<p>MVVM是一种设计模式, 从后端的 MVC模式 演化而来</p>
<ul>
<li>M Model 数据模型 可以是自己准备回来的数据 也可以是请求回来的数据</li>
<li>V View 视图相关的</li>
<li>VM ViewModel 视图模型 既可以操作数据 又可以操作视图<br>
<img src="https://lucas-y.github.io//post-images/1608864082496.png" alt="" loading="lazy"></li>
</ul>
<h2 id="vue初体验">vue初体验</h2>
<ol>
<li>安装下载 vue</li>
</ol>
<pre><code class="language-txt">npm i vue
</code></pre>
<ol start="2">
<li>引入一个 vue</li>
<li>使用 vue - 初始化 vue 实例  <strong>指定视图 和 数据</strong></li>
</ol>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;h1&gt;{{ msg }}&lt;/h1&gt;
  &lt;h1&gt;{{ msg }}&lt;/h1&gt;
&lt;/div&gt;

&lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  // 只要引入 vue.js, 那么全局就有了一个Vue 构造函数
  // 创建vue实例
  const vm = new Vue({
    // 指定视图 + 数据
    // 1. el element, 用于指定vue所管理的视图范围, 值是一个选择器
    el: '#app',
    // 2. data, 用于指定vue中可以使用的数据
    data: {
      msg: '你好, vue'
    }
  })
&lt;/script&gt;
</code></pre>
<h2 id="vue使用的注意点">vue使用的注意点</h2>
<ol>
<li>new Vue() 构造函数Vue, 首字母大写</li>
<li>el 不能指定为 html 和 body, 但是可以是一个大的div</li>
<li>到了vue, 不要老想着操作dom了, <code>要更新视图, 操作数据即可</code></li>
</ol>
<h2 id="vue的插值表达式">vue的插值表达式</h2>
<p>插值表达式, 小胡子语法<code>{{ }}</code></p>
<ol>
<li>作用:  使用 data 中的数据渲染视图</li>
<li>基本语法, 支持三元运算符<pre><code class="language-jsx">{{ msg }}
{{ obj.name }}
{{ msg.toUpperCase() }}
{{ obj.age &gt; 18 ? '成年' : '未成年' }}
</code></pre>
</li>
<li>vue中插值表达式的注意点<br>
(1)  使用的数据在 data 中要存在<pre><code class="language-jsx">&lt;h1&gt;{{ gaga }}&lt;/h1&gt;
</code></pre>
(2)  能使用表达式, 但是不能使用 if  for<pre><code class="language-jsx">&lt;h1&gt;{{ if (obj.age &gt; 18 ) { }   }}&lt;/h1&gt;
</code></pre>
(3)  不能在标签属性中使用<pre><code class="language-jsx">&lt;h1 id=&quot;box&quot; class=&quot;box&quot; title=&quot;{{ msg }}&quot;&gt;&lt;/h1&gt;
</code></pre>
</li>
</ol>
<h2 id="vue指令">vue指令</h2>
<p><strong>vue指令, 实质上就是特殊的 html 标签属性, 特点:  v- 开头</strong><br>
每个 v- 开头的指令, 都有着自己独立的功能, 将来vue解析时, 会根据不同的指令提供不同的功能</p>
<h3 id="v-text-和-v-html">v-text 和 v-html</h3>
<ul>
<li>v-text 设置元素的 innerText, 不识别标签, 基本可以被 插值表达式 替代, 不太常用</li>
<li>v-html 设置元素的 innerHTML, 可以识别标签,  需要识别标签的时候, 使用v-html即可</li>
</ul>
<h3 id="v-if-和-v-show">v-if 和 v-show</h3>
<p>v-show 和 v-if 功能: 控制盒子的显示隐藏</p>
<ol>
<li>v-show<br>
语法:  v-show=&quot;布尔值&quot;    (true显示, false隐藏)<br>
原理:  实质是在控制元素的 css 样式,  <code>display: none;</code></li>
<li>v-if<br>
语法: v-if=&quot;布尔值&quot;   (true显示, false隐藏)<br>
原理:  实质是在动态的创建 或者 删除元素节点<br>
应用场景:</li>
</ol>
<ul>
<li>如果是频繁的切换显示隐藏, 用 v-show<br>
v-if, 频繁切换会大量的创建和删除元素, 消耗性能</li>
<li>如果是不用频繁切换, 要么显示, 要么隐藏的情况, 适合于用 v-if<br>
v-if 是<code>惰性</code>的, 如果初始值为 false, 那么这些元素就直接不创建了, 节省一些初始渲染开销</li>
</ul>
<h3 id="v-if-v-else-if-v-else">v-if v-else-if v-else</h3>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;h1 v-if=&quot;isLogin&quot;&gt;尊敬的超级vip, 你好&lt;/h1&gt;
  &lt;h1 v-else&gt;你谁呀, 赶紧登陆~&lt;/h1&gt;
  &lt;hr&gt;
  &lt;h1 v-if=&quot;age &gt;= 60&quot;&gt;60岁以上, 广场舞&lt;/h1&gt;
  &lt;h1 v-else-if=&quot;age &gt;= 30&quot;&gt;30岁以上, 搓麻将&lt;/h1&gt;
  &lt;h1 v-else-if=&quot;age &gt;= 20&quot;&gt;20岁以上, 蹦迪&lt;/h1&gt;
  &lt;h1 v-else&gt;20岁以下, 唱跳rap篮球&lt;/h1&gt;
&lt;/div&gt;

&lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  const vm = new Vue({
    el: '#app',
    data: {
      msg: 'hello vue',
      isLogin: true,
      age: 18
    }
  })
&lt;/script&gt;
</code></pre>
<h3 id="v-on指令">v-on指令</h3>
<ol>
<li>用于注册事件</li>
</ol>
<ul>
<li>写内联语句, 将要执行的代码直接写在 &quot;&quot; 内部, 适合写少量代码<br>
v-on:事件名=&quot;要执行的代码&quot;</li>
<li>指向methods中的定义的函数<br>
v-on:事件名=&quot;methods中的函数&quot;</li>
<li>指向methods中的定义的函数，并传入参数<br>
v-on:事件名=&quot;methods中的函数(实参)&quot;<br>
<code>简写: @事件名</code></li>
</ul>
<ol start="2">
<li>vue中获取事件对象</li>
</ol>
<blockquote>
<p>需求: 默认a标签点击会跳走,  希望阻止默认的跳转, 阻止默认行为  e.preventDefault()</p>
</blockquote>
<ul>
<li>没有传参, 通过形参接收 e</li>
<li>传参了, 通过$event指代事件对象 e</li>
</ul>
<ol start="3">
<li>事件修饰符</li>
</ol>
<ul>
<li><code>.prevent</code> 阻止默认行为</li>
<li><code>.stop</code> 阻止冒泡</li>
</ul>
<ol start="4">
<li>案件修饰符</li>
</ol>
<blockquote>
<p>在监听键盘事件时，我们经常需要判断详细的按键。此时，可以为键盘相关的事件添加按键修饰符</p>
</blockquote>
<ul>
<li><code>@keyup.enter</code>  回车触发</li>
<li><code>@keyup.esc</code>  返回触发</li>
</ul>
<h3 id="v-bind指令">v-bind指令</h3>
<p><strong>作用: 访问data中的数据,  动态的设置html的标签属性</strong><br>
语法: <code>v-bind:属性名=&quot;值&quot;</code> ,  简写 <code>:属性名=&quot;值&quot;</code></p>
<ul>
<li>v-bind 对于类名操作的增强, 注意点, :class 不会影响到原来的 class 属性<br>
:class=&quot;对象/数组&quot;</li>
</ul>
<pre><code class="language-js">(1) :class=&quot;对象&quot; 
	{ 类名: 布尔值, 类名: 布尔值 } 
	如果是true, 加上这个类, 如果是false, 移除这个类

(2) :class=&quot;数组&quot;
	['类名1', '类名2', '类名3']
	只要有这个类, 就加上

(3) :class=&quot;对象/数组&quot; 直接内联在结构中编写 (重点)
</code></pre>
<ul>
<li>v-bind对于style 的增强</li>
</ul>
<pre><code>:style=&quot;对象&quot;  =&gt; :style=&quot;obj&quot;  =&gt;  :style=&quot;{ width: '200px' }&quot;
</code></pre>
<h3 id="v-for">v-for</h3>
<p>遍历对象和数组</p>
<ol>
<li>遍历数组 (常用)</li>
</ol>
<pre><code class="language-txt">v-for=&quot;item in 数组名&quot;  item每一项
v-for=&quot;(item, index) in 数组名&quot;  item每一项 index下标
</code></pre>
<ol start="2">
<li>遍历对象 (一般不用)</li>
</ol>
<pre><code class="language-txt">v-for=&quot;(value, prop) in 对象&quot;  value属性值, prop属性名
</code></pre>
<ol start="3">
<li>v-for 的key的说明</li>
</ol>
<ul>
<li>vue 的更新机制的说明<br>
数据变化了, vue会对比<code>新旧 虚拟 dom</code>的差异,  对比出差异, 进行差异化更新 (高效)</li>
<li>为啥不对比真实dom, 而对比虚拟dom?  =&gt;  提升对比效率</li>
<li>key 只是给 虚拟dom 添加了一个唯一的标识, 改变了同级兄弟元素的对比复用策略, 进而优化列表的渲染更新性能<br>
<code>总结</code>: 一般为了优化渲染的性能, 可以在遍历列表时, 加上一个 key属性, key一般指定成 id</li>
</ul>
<h3 id="v-model">v-model</h3>
<p>**作用: 给表单元素使用, 双向数据绑定 **<br>
<strong>语法: v-model='值'</strong></p>
<ol>
<li>
<p>数据变化了, 视图会跟着变<br>
数据劫持(监听数据的变化)<br>
vue2: Object.defineProperty<br>
vue3: proxy</p>
</li>
<li>
<p>视图变化了, 数据要跟着变<br>
输入框内容变化了(监听用户的输入, 监听input事件), 数据要跟着变</p>
</li>
<li>
<p>v-model 处理其他表单元素<br>
<strong>v-model 会忽略掉表单元素原本的value, checked等初始值</strong><br>
<code>textarea, select, checkbox</code></p>
</li>
</ol>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt;
  &lt;hr&gt;
  &lt;textarea v-model=&quot;desc&quot;&gt;&lt;/textarea&gt;
  &lt;p&gt;{{ desc }}&lt;/p&gt;
  &lt;hr&gt;
  &lt;!-- select框的value值, 就是选中的option的value值 
       1. 可以用于获取
       2. 还可以用于设置
  --&gt;
  &lt;select v-model=&quot;cityId&quot;&gt;
    &lt;option value=&quot;1&quot;&gt;上海&lt;/option&gt;
    &lt;option value=&quot;2&quot;&gt;无锡&lt;/option&gt;
    &lt;option value=&quot;3&quot;&gt;香港&lt;/option&gt;
    &lt;option value=&quot;4&quot;&gt;北京&lt;/option&gt;
    &lt;option value=&quot;5&quot;&gt;哈尔滨&lt;/option&gt;
    &lt;option value=&quot;6&quot;&gt;齐齐哈尔&lt;/option&gt;
  &lt;/select&gt;
  &lt;p&gt;{{ cityId }}&lt;/p&gt;
  &lt;hr&gt;
  &lt;input type=&quot;checkbox&quot; v-model=&quot;flag&quot;&gt;
  &lt;p&gt;{{ flag }}&lt;/p&gt;
&lt;/div&gt;

&lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  // 注意点: v-model设置了之后, 会忽略掉默认设置的value, checked等属性
  // 表单元素小练习
  // 1. textarea  value
  // 2. select/option  value
  // 3. checkbox复选框  checked属性

  const vm = new Vue({
    el: '#app',
    data: {
      msg: '123456',
      desc: '今天天气还行',
      cityId: 6,
      flag: false
    }
  })
&lt;/script&gt;
</code></pre>
<ol start="4">
<li>v-model 修饰符</li>
</ol>
<ul>
<li>
<p>number<br>
如果想自动将用户的输入值, 用parseFloat转成数字类型, ，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符：</p>
<pre><code class="language-html">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;
</code></pre>
<p>如果这个值如果这个值无法转数字，则会返回原始的值。</p>
</li>
<li>
<p>trim<br>
如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符：</p>
<pre><code class="language-html">&lt;input v-model.trim=&quot;msg&quot;&gt;
</code></pre>
</li>
<li>
<p>lazy<br>
在<code>change</code>时而非<code>input</code>时更新，可以给 <code>v-model</code> 添加 <code>lazy</code> 修饰符：<br>
对于 input:text 文本框, 监听用户的修改</p>
<blockquote>
<p>change   失去焦点 或 用户回车, 确认改完了触发 (了解);  input    只要用户输入了, 实时触发</p>
</blockquote>
<pre><code class="language-html">&lt;input v-model.lazy=&quot;msg&quot;&gt;
</code></pre>
</li>
</ul>
<ol start="5">
<li>如何实现v-model<br>
v-model 其实是 vue 给你提供的一种简化表单元素操作的语法糖<br>
**本质上做了两件事 **</li>
</ol>
<ul>
<li>动态设置表单元素的值</li>
</ul>
<pre><code class="language-jsx">&lt;input type=&quot;checkbox&quot; class=&quot;custom-control-input&quot; :id=&quot;'switch' + item.id&quot; :checked=&quot;item.state&quot; @change=&quot;changeState(item, $event)&quot;&gt;
</code></pre>
<ul>
<li>监听对应的事件, 表单元素值变化时, 更新到绑定的变量中</li>
</ul>
<pre><code class="language-jsx">changeState (item, e) {
  item.state = e.target.checked
}
</code></pre>
<h2 id="过滤器">过滤器</h2>
<h3 id="过滤器的兼容性">过滤器的兼容性</h3>
<blockquote>
<p>vue2.0 中推荐使用过滤器, 处理格式<br>
vue3.0 移除了过滤器, vue3.0 内部进行性能优化, 可以直接调用方法,  就可以解决之前过滤器的需求, 所以废弃了</p>
</blockquote>
<h3 id="过滤器的基本使用">过滤器的基本使用</h3>
<p>过滤器的作用: 转换格式<br>
过滤器本质上就是一个函数</p>
<pre><code>格式x --- 过滤器 -----&gt; 格式y
</code></pre>
<p>将来开发过程中, 肯定会有对于字符串进行处理转换的需求, vue中提供了一个专门的语法: 过滤器</p>
<ol>
<li>定义过滤器<br>
Vue.filter(过滤器名字, 处理字符串的函数)<br>
(1) 函数的返回值, 就是处理字符串的结果<br>
(2) 函数的形参, 可以拿到处理的字符串</li>
<li>使用过滤器 <code>{{ msg | 过滤器名字 }}</code></li>
</ol>
<h3 id="利用过滤器处理日期">利用过滤器处理日期</h3>
<p>moment官网文档: http://momentjs.cn/docs/#/displaying/<br>
<img src="https://lucas-y.github.io//post-images/1608949217588.png" alt="" loading="lazy"><br>
<img src="https://lucas-y.github.io//post-images/1608949250606.png" alt="" loading="lazy"><br>
<img src="https://lucas-y.github.io//post-images/1608949256751.png" alt="" loading="lazy"></p>
<h3 id="过滤器的参数">过滤器的参数</h3>
<p>使用过滤器支持传参</p>
<pre><code>{{ msg | 过滤器名字(参数1, 参数2) }}
</code></pre>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;h1&gt;{{ date1 | time(&quot;YYYY-MM-DD&quot;) }}&lt;/h1&gt;
  &lt;h2&gt;{{ date2 | time }}&lt;/h2&gt;
  &lt;h2&gt;{{ date2 | time }}&lt;/h2&gt;
&lt;/div&gt;

&lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;./node_modules/moment/moment.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  Vue.filter('time', function(value, str='YYYY年MM月DD日 HH:mm:ss') {
    return moment(value).format(str)
  })

  const vm = new Vue({
    el: '#app',
    data: {
      date1: 1601305782038,
      date2: 1201305782038
    }
  })
&lt;/script&gt;
</code></pre>
<h3 id="全局过滤器-和-局部过滤器">全局过滤器 和 局部过滤器</h3>
<p>全局过滤器: 在所有的vue实例中, 都可以使用<br>
局部过滤器: 只能在当前的vue实例中, 使用</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;h1&gt;{{ msg | global | demo }}&lt;/h1&gt;
&lt;/div&gt;

&lt;div id=&quot;app2&quot;&gt;
  &lt;h1&gt;{{ msg | global | demo }}&lt;/h1&gt;
&lt;/div&gt;

&lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  // 全局过滤器: 在所有的vue实例中, 都可以使用 
  // 局部过滤器: 只能在当前的vue实例中, 使用
  Vue.filter('global', function(value) {
    return value + '_global'
  })

  const vm = new Vue({
    el: '#app',
    data: {
      msg: 'hello vue'
    },
    filters: {
      // 过滤器名字: 处理函数
      demo: function(value) {
        return value + '_demo'
      }
    }
  })

  const vm2 = new Vue({
    el: '#app2',
    data: {
      msg: 'hello vue2'
    }
  })
&lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[四象限工作法]]></title>
        <id>https://lucas-y.github.io/post/demo/</id>
        <link href="https://lucas-y.github.io/post/demo/">
        </link>
        <updated>2020-12-08T10:09:34.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/30b2ab0dc20e">链接</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重要知识点]]></title>
        <id>https://lucas-y.github.io/post/keypoints/</id>
        <link href="https://lucas-y.github.io/post/keypoints/">
        </link>
        <updated>2020-12-08T09:33:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="重要知识点">重要知识点</h1>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7256693"><label class="task-list-item-label" for="task-item-7256693"> 面试题</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2108636"><label class="task-list-item-label" for="task-item-2108636"> 浏览器优化</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5864209"><label class="task-list-item-label" for="task-item-5864209"> 工作中遇到的难点</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4044105"><label class="task-list-item-label" for="task-item-4044105"> seo（花钱，html后缀，外链，标签语义化）</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3342996"><label class="task-list-item-label" for="task-item-3342996"> 前端开发优化问题</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9171275"><label class="task-list-item-label" for="task-item-9171275"> 浏览器兼容</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7067676"><label class="task-list-item-label" for="task-item-7067676"> css</label>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1512854"><label class="task-list-item-label" for="task-item-1512854"> 双微元素清除</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2821467"><label class="task-list-item-label" for="task-item-2821467"> 浮动</label></li>
</ul>
</li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5380607"><label class="task-list-item-label" for="task-item-5380607"> HTML5（语义化，seo，移动端，游戏）</label></li>
</ul>
<h2 id="vue">vue</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2622207"><label class="task-list-item-label" for="task-item-2622207"> 父子组件生命周期触发时机</label>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3251585"><label class="task-list-item-label" for="task-item-3251585"> createdF ===> createdS</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7775900"><label class="task-list-item-label" for="task-item-7775900"> mountedS ===> mountedF</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1190114"><label class="task-list-item-label" for="task-item-1190114"> updatedS ===> updatedF</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6960167"><label class="task-list-item-label" for="task-item-6960167"> destroyedS ===> destroyedF</label></li>
</ul>
</li>
</ul>
<h2 id="react">react</h2>
<ul class="contains-task-list">
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6304754"><label class="task-list-item-label" for="task-item-6304754"> setState</label></p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-997164"><label class="task-list-item-label" for="task-item-997164"> 组件的更新机制依靠事务进行批量更新</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9743850"><label class="task-list-item-label" for="task-item-9743850"> 将state的更新延缓到最后批量合并再去渲染对于应用的性能优化是有极大好处的，如果每次的状态改变都去重新渲染真实dom，那么它将带来巨大的性能消耗。</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4114835"><label class="task-list-item-label" for="task-item-4114835"> 保证内部的一致性：即使state是同步更新，props也不是。（你只有在父组件重新渲染时才能知道props）</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7186086"><label class="task-list-item-label" for="task-item-7186086"> setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。生命周期函数和合成函数中调用setState表现异步更新，是因为组件初始化和调用合成函数时都会触发ReactDefaultBatchingStrategy事务的batchUpdates方法，将批量更新标记设置为true，所以后面的setState都会存储到dirtyComponents中，执行批量更新之后再将标志设置为false</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4090940"><label class="task-list-item-label" for="task-item-4090940"> setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果</label></li>
</ul>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7652073"><label class="task-list-item-label" for="task-item-7652073"> 生命周期</label></p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9483775"><label class="task-list-item-label" for="task-item-9483775"> constructor->componentWillMount->render->componentDidMount</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4754079"><label class="task-list-item-label" for="task-item-4754079"> componentWillReceiveProps->shouldComponentUpdate->componentWillUpdate->render->componentDidUpdate</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-8355849"><label class="task-list-item-label" for="task-item-8355849"> componentWillUnmount</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-436112"><label class="task-list-item-label" for="task-item-436112"> componentDidCatch getDerivedStateFromError</label></li>
</ul>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1081586"><label class="task-list-item-label" for="task-item-1081586"> react项目打包优化</label></p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-209122"><label class="task-list-item-label" for="task-item-209122"> antd-mobile组件库按需加载（react-app-rewired，customize-cra，babel-plugin-import，config-overrides.js）</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2006312"><label class="task-list-item-label" for="task-item-2006312">  基于路由的代码分割实现组件的按需加载，提高首屏加载速度（React.lazy，import，Suspense，fallback）</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-8716314"><label class="task-list-item-label" for="task-item-8716314">  creat-react-app脚手架内部有大量优化</label></li>
</ul>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-8431231"><label class="task-list-item-label" for="task-item-8431231"> 组件性能优化</label></p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3804578"><label class="task-list-item-label" for="task-item-3804578"> 减轻state（无关数据或者ref，定时器绑this）</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1038353"><label class="task-list-item-label" for="task-item-1038353"> shouldComponentUpdate</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7946724"><label class="task-list-item-label" for="task-item-7946724"> 纯组件</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3641639"> 列表map <strong>key</strong><label class="task-list-item-label" for="task-item-3641639"> 列表map **key**</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3794736"><label class="task-list-item-label" for="task-item-3794736"> 不可变性 创建新对象 而不是在原有引用上修改</label></li>
</ul>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-8374062"> <a href="https://juejin.cn/post/6844903813070094350">react副作用<label class="task-list-item-label" for="task-item-8374062"> [react副作用](https://juejin.cn/post/6844903813070094350)</label></p>
</li>
</ul>
<h2 id="css">css</h2>
<pre><code>继承&lt;通配符选择器&lt;标签选择器&lt;类选择器&lt;id选择器&lt;行内样式&lt;！important

解决marign的塌陷现象：
        1、父元素设置border-top
        2、父元素设置padding-top
        3、父元素设置overflow：hidden
        4、设置浮动
        5、display：inline-block
 
 清除浮动的几种方法：
      1、额外标签法 (在内容的最后，块级元素)
          1、在父元素内容的最后添加一个块级元素
          2、需要给块级元素设置一个清除浮动的核心代码  clear：both；
        缺点：就是在页面中添加了一些多余的标签

      2、单伪元素清除法
          本质上来说就是额外标签法，使用的是伪元素完成效果的！！
          ::after

      3、直接给父元素设置overflow：hidden

      4、简单粗暴：直接设置高度
 
 .clearfix::before,
    .clearfix::after {
      content: '';
      display: table;
    }
    .clearfix::after {
      clear: both;
    }
    /*兼容ie浏览器*/
    .clearfix {
      *zoom:1;
    }
</code></pre>
<h2 id="js">js</h2>
<ul class="contains-task-list">
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4245058"> <a href="https://juejin.im/post/5b8f76675188255c7c653811">eventloop<label class="task-list-item-label" for="task-item-4245058"> [eventloop](https://juejin.im/post/5b8f76675188255c7c653811)</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3864269"> <a href="https://juejin.im/post/5c41297cf265da613356d4ec">promise<label class="task-list-item-label" for="task-item-3864269"> [promise](https://juejin.im/post/5c41297cf265da613356d4ec)</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5493794"> <a href="https://www.bilibili.com/video/BV1MJ41197Eu?p=40">手写promise<label class="task-list-item-label" for="task-item-5493794"> [手写promise](https://www.bilibili.com/video/BV1MJ41197Eu?p=40)</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-8832113"><label class="task-list-item-label" for="task-item-8832113"> 原型链</label></p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5162662"><label class="task-list-item-label" for="task-item-5162662"> 任何一个对象，都有原型对象，原型对象本身又是一个对象，所以原型对象也有自己的原型对象，这样一环扣一环就形成了一个链式结构，我们把这个链式结构称为：原型链。</label></li>
</ul>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5737528"> <a href="https://www.cnblogs.com/sarahwang/p/6870072.html">继承<label class="task-list-item-label" for="task-item-5737528"> [继承](https://www.cnblogs.com/sarahwang/p/6870072.html)</label></p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2513143"><label class="task-list-item-label" for="task-item-2513143"> 原型链继承</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5176339"><label class="task-list-item-label" for="task-item-5176339"> 借用构造函数</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4496974"><label class="task-list-item-label" for="task-item-4496974"> 组合继承</label></li>
</ul>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5862110"><label class="task-list-item-label" for="task-item-5862110"> 深拷贝 （封装递归函数，JSON.parse（JSON.stringify））</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9159903"><label class="task-list-item-label" for="task-item-9159903"> 浅拷贝 （Object.assign，...展开）</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5822907"><label class="task-list-item-label" for="task-item-5822907"> 闭包</label></p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6015964"><label class="task-list-item-label" for="task-item-6015964"> 内函数访问外函数的局部变量，形成闭包（优：沙箱，插件；劣：内存泄漏）</label></li>
</ul>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-8890492"><label class="task-list-item-label" for="task-item-8890492"> call（性能比apply好）,apply,bind</label></p>
<pre><code class="language-js">Function.prototype.myCall = function (_this = window, ...rest) {
  _this._this = this;
  const result = _this._this(...rest);
  delete _this._this;
  return result;
}
</code></pre>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5806833"><label class="task-list-item-label" for="task-item-5806833"> 前端模块化</label></p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5150198"><label class="task-list-item-label" for="task-item-5150198"> 自执行函数</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1756438"><label class="task-list-item-label" for="task-item-1756438"> commonJS规范 node</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2629227"><label class="task-list-item-label" for="task-item-2629227"> esmodule ES6</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-599110"><label class="task-list-item-label" for="task-item-599110"> AMD require.js 依赖前置</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7076493"><label class="task-list-item-label" for="task-item-7076493"> CMD sea.js 依赖就近</label></li>
</ul>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7006989"><label class="task-list-item-label" for="task-item-7006989"> ==</label></p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-8755456"><label class="task-list-item-label" for="task-item-8755456"> NaN不等于任何值</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1456788"><label class="task-list-item-label" for="task-item-1456788"> null，undefined只等于null，undefined</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3058133"><label class="task-list-item-label" for="task-item-3058133"> 两边有数字或者布尔，转数字比较</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2362416"><label class="task-list-item-label" for="task-item-2362416"> 两边有字符串，转字符串比较</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9505434"><label class="task-list-item-label" for="task-item-9505434"> 复杂类型比地址( []转"", {}转"[object Object]" )</label></li>
</ul>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4103691"><label class="task-list-item-label" for="task-item-4103691"> this</label></p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6821592"><label class="task-list-item-label" for="task-item-6821592"> 事件处理程序里this指向事件源(注册事件的那个dom)</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-424713"><label class="task-list-item-label" for="task-item-424713"> 构造函数（配合new）里的this指向刚刚创建的对象</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7050908"><label class="task-list-item-label" for="task-item-7050908"> setTimeout setInterval this指向window</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4889847"><label class="task-list-item-label" for="task-item-4889847"> 普通函数fn调用模式  fn() this===>>>window</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3678514"><label class="task-list-item-label" for="task-item-3678514"> 对象调用模式 obj.fn()  this===>>>obj(调用者)</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3399642"><label class="task-list-item-label" for="task-item-3399642"> call,apply,bind this===>>>第一个参数(没传参就是window)</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9440187"><label class="task-list-item-label" for="task-item-9440187"> 箭头函数没有this，所以如果箭头函数有this（this指向包裹它的局部作用域）</label></li>
<li>[ ]</li>
</ul>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3841197"><label class="task-list-item-label" for="task-item-3841197"> es6</label></p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3355202"><label class="task-list-item-label" for="task-item-3355202"> let (有块级作用域，不能重复定义，不会预解析，先声明再使用，不挂到window)</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4764598"><label class="task-list-item-label" for="task-item-4764598"> const（有块级作用域，不能重复定义，不会预解析，先声明再使用,常量，定义就赋值，不挂到window）</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6955261"><label class="task-list-item-label" for="task-item-6955261"> forEach,map,filter,some,every,find,findIndex，reduce</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6340936"><label class="task-list-item-label" for="task-item-6340936"> 解构赋值</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6048947"><label class="task-list-item-label" for="task-item-6048947"> 模版字符串</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6853336"><label class="task-list-item-label" for="task-item-6853336"> 字符串新增startsWith，endsWith，includes</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9870986"><label class="task-list-item-label" for="task-item-9870986"> 箭头函数</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9506871"><label class="task-list-item-label" for="task-item-9506871"> 函数默认值，剩余参数</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2961577"><label class="task-list-item-label" for="task-item-2961577"> 对象属性简写，方法简写</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3764865"><label class="task-list-item-label" for="task-item-3764865"> ...展开运算符</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7622911"><label class="task-list-item-label" for="task-item-7622911"> set，map</label></li>
</ul>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5968442"><label class="task-list-item-label" for="task-item-5968442"> 浏览器存储</label></p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6505249"><label class="task-list-item-label" for="task-item-6505249"> cookie 小 每次请求自动携带 有销毁时间</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5322416"><label class="task-list-item-label" for="task-item-5322416"> localStorage 大 手动清理</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4584299"><label class="task-list-item-label" for="task-item-4584299"> sessionStorage 大 页面关闭就清理</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9051425"><label class="task-list-item-label" for="task-item-9051425"> indexDB 用不完 手动清理</label></li>
</ul>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4433742"><label class="task-list-item-label" for="task-item-4433742"> async （Promise的语法糖）es7</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3357499"><label class="task-list-item-label" for="task-item-3357499"> addEventLisntener(第三个参数如果true，表示该事件在捕获阶段执行，  如果false，表示事件在冒泡阶段执行。默认在冒泡阶段执行)</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9305518"><label class="task-list-item-label" for="task-item-9305518"> new做了什么？</label></p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2564791"><label class="task-list-item-label" for="task-item-2564791"> 创建对象 this指向该对象</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-589463"><label class="task-list-item-label" for="task-item-589463"> 继承函数原型</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2709387"><label class="task-list-item-label" for="task-item-2709387"> 实例化</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3716158"><label class="task-list-item-label" for="task-item-3716158"> 隐式返回该对象</label></li>
</ul>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9472567"><label class="task-list-item-label" for="task-item-9472567"> webpack</label></p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2268921"><label class="task-list-item-label" for="task-item-2268921"> entry</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1608054"><label class="task-list-item-label" for="task-item-1608054"> output</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5917098"><label class="task-list-item-label" for="task-item-5917098"> module（loader）</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-970398"><label class="task-list-item-label" for="task-item-970398"> plugins</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4135783"><label class="task-list-item-label" for="task-item-4135783"> devServer</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7095985"><label class="task-list-item-label" for="task-item-7095985"> mode</label></li>
</ul>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3400164"> <a href="https://segmentfault.com/a/1190000015597029">跨域<label class="task-list-item-label" for="task-item-3400164"> [跨域](https://segmentfault.com/a/1190000015597029)</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-571666"><label class="task-list-item-label" for="task-item-571666"> node（运行环境，允许js运行在服务端）</label></p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5559778"><label class="task-list-item-label" for="task-item-5559778"> global顶级变量</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3723401"><label class="task-list-item-label" for="task-item-3723401"> fs模块 path模块</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-8901992"><label class="task-list-item-label" for="task-item-8901992"> http模块</label></li>
</ul>
<pre><code class="language-js">  const http = require('http')
  const server = http.createServer()
  server.listen(8888, () =&gt; {
    console.log('恭喜你，服务器启动成功了')
  })
  server.on('request', (req, res) =&gt; {
    console.log('来了老弟')
    res.end('hello old brother')
  })
</code></pre>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9856170"><label class="task-list-item-label" for="task-item-9856170"> 浏览器垃圾回收机制</label></p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9280537"><label class="task-list-item-label" for="task-item-9280537"> 引用计数（循环引用无法解决）</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6654513"><label class="task-list-item-label" for="task-item-6654513"> 标记清除</label></li>
</ul>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4706810"> 节流（指定时间间隔只触发一次）<a href="https://segmentfault.com/a/1190000018428170">link<label class="task-list-item-label" for="task-item-4706810"> 节流（指定时间间隔只触发一次）[link](https://segmentfault.com/a/1190000018428170)</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-144281"><label class="task-list-item-label" for="task-item-144281"> 防抖（动作触发后指定时间间隔内不再触发，执行某个函数）</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-8453480"> <a href="https://juejin.im/post/59aa71d56fb9a0248d24fae3">箭头函数 this</a> <strong>定义函数时所在上下文中的 this</strong><label class="task-list-item-label" for="task-item-8453480"> [箭头函数 this](https://juejin.im/post/59aa71d56fb9a0248d24fae3) **定义函数时所在上下文中的 this**</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3800893"><label class="task-list-item-label" for="task-item-3800893"> 异步</label></p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-8721305"><label class="task-list-item-label" for="task-item-8721305"> 回调（解决同步，回调地狱）</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1749154"><label class="task-list-item-label" for="task-item-1749154"> promise（解决回调地狱，无法取消promise）</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7981018"><label class="task-list-item-label" for="task-item-7981018"> generator（可以控制函数执行，dva）</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2448091"><label class="task-list-item-label" for="task-item-2448091"> async await（代码清晰，性能低）</label></li>
</ul>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7021072"> <a href="https://juejin.im/post/5a276865f265da432c23b8d2">http常见状态码<label class="task-list-item-label" for="task-item-7021072"> [http常见状态码](https://juejin.im/post/5a276865f265da432c23b8d2)</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7650183"><label class="task-list-item-label" for="task-item-7650183"> git cherry-pick 8d03e78 用来复制某个分支上的某次提交</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3854208"><label class="task-list-item-label" for="task-item-3854208"> 两个已经提交的分支的相同文件相同位置的的不同操作进行了合并.就是冲突</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1018186"> <a href="https://blog.csdn.net/jdsjlzx/article/details/98654951">git tag 使用<label class="task-list-item-label" for="task-item-1018186"> [git tag 使用](https://blog.csdn.net/jdsjlzx/article/details/98654951)</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-8545236"><label class="task-list-item-label" for="task-item-8545236"> git stash -u  /  git stash pop</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7252778"> <a href="https://www.cnblogs.com/dyh-air/p/9257237.html">git push -u origin master<label class="task-list-item-label" for="task-item-7252778"> [git push -u origin master](https://www.cnblogs.com/dyh-air/p/9257237.html)</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-668676"> <a href="https://blog.csdn.net/weixin_44761910/article/details/105029748">Git本地与远程分支间建立追踪关系<label class="task-list-item-label" for="task-item-668676"> [Git本地与远程分支间建立追踪关系](https://blog.csdn.net/weixin_44761910/article/details/105029748)</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-617481"> <a href="https://blog.csdn.net/L_serein/article/details/8550976?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">navigator.userAgent<label class="task-list-item-label" for="task-item-617481"> [navigator.userAgent](https://blog.csdn.net/L_serein/article/details/8550976?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control)</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9072166"> <a href="https://blog.csdn.net/huang100qi/article/details/80237555">hash/histroy<label class="task-list-item-label" for="task-item-9072166"> [hash/histroy](https://blog.csdn.net/huang100qi/article/details/80237555)</label></p>
</li>
</ul>
<h2 id="hook">hook</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2136509"> <a href="https://juejin.cn/post/6844903813070094350">react副作用<label class="task-list-item-label" for="task-item-2136509"> [react副作用](https://juejin.cn/post/6844903813070094350)</label></li>
</ul>
<h2 id="typescript">typescript</h2>
]]></content>
    </entry>
</feed>